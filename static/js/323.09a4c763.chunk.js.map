{"version":3,"file":"static/js/323.09a4c763.chunk.js","mappings":"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","sources":["../node_modules/parse-svg-path/index.js","../node_modules/pixi.js/src/app/ResizePlugin.ts","../node_modules/pixi.js/src/app/TickerPlugin.ts","../node_modules/pixi.js/src/app/init.ts","../node_modules/pixi.js/src/filters/FilterPipe.ts","../node_modules/pixi.js/src/scene/container/bounds/getFastGlobalBounds.ts","../node_modules/pixi.js/src/filters/FilterSystem.ts","../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts","../node_modules/pixi.js/src/filters/init.ts","../node_modules/pixi.js/src/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.ts","../node_modules/pixi.js/src/rendering/batcher/gl/utils/maxRecommendedTextures.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts","../node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts","../node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getTestContext.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts","../node_modules/pixi.js/src/rendering/renderers/shared/buffer/Buffer.ts","../node_modules/pixi.js/src/rendering/renderers/shared/buffer/const.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/ensureIsBuffer.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/Geometry.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/types.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts","../node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","../node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts","../node_modules/pixi.js/src/rendering/renderers/shared/state/getAdjustedBlendModeBlend.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/CanvasPool.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts","../node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts","../node_modules/pixi.js/src/rendering/renderers/types.ts","../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","../node_modules/pixi.js/src/scene/graphics/init.ts","../node_modules/pixi.js/src/scene/graphics/shared/BatchableGraphics.ts","../node_modules/pixi.js/src/scene/container/utils/multiplyHexColors.ts","../node_modules/pixi.js/src/maths/shapes/Circle.ts","../node_modules/pixi.js/src/maths/shapes/Ellipse.ts","../node_modules/pixi.js/src/maths/misc/squaredDistanceToLineSegment.ts","../node_modules/pixi.js/src/maths/shapes/Polygon.ts","../node_modules/pixi.js/src/maths/shapes/RoundedRectangle.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts","../node_modules/pixi.js/src/scene/graphics/shared/path/ShapePath.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcTo.ts","../node_modules/pixi.js/src/scene/graphics/shared/path/roundShape.ts","../node_modules/pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts","../node_modules/pixi.js/src/scene/graphics/shared/svg/SVGToGraphicsPath.ts","../node_modules/pixi.js/src/scene/graphics/shared/svg/SVGParser.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsContext.ts","../node_modules/pixi.js/src/rendering/batcher/gpu/getTextureBatchBindGroup.ts","../node_modules/pixi.js/src/rendering/renderers/shared/buffer/utils/fastCopy.ts","../node_modules/pixi.js/src/rendering/batcher/shared/BatchTextureArray.ts","../node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts","../node_modules/pixi.js/src/rendering/batcher/shared/BatchGeometry.ts","../node_modules/pixi.js/src/rendering/batcher/shared/DefaultShader.ts","../node_modules/pixi.js/src/rendering/batcher/shared/DefaultBatcher.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts","../node_modules/pixi.js/src/scene/graphics/shared/utils/triangulateWithHoles.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPolygon.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildRectangle.ts","../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildTriangle.ts","../node_modules/pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts","../node_modules/pixi.js/src/scene/graphics/shared/const.ts","../node_modules/pixi.js/src/scene/graphics/shared/utils/getOrientationOfPoints.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts","../node_modules/pixi.js/src/scene/graphics/shared/fill/FillGradient.ts","../node_modules/pixi.js/src/scene/graphics/shared/fill/FillPattern.ts","../node_modules/pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","../node_modules/pixi.js/src/scene/mesh/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts","../node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts","../node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/init.ts","../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","../node_modules/pixi.js/src/scene/sprite-tiling/init.ts","../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","../node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","../node_modules/pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts","../node_modules/pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts","../node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts","../node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapFontManager.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","../node_modules/pixi.js/src/scene/text-bitmap/init.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","../node_modules/pixi.js/src/scene/text-html/utils/textStyleToCSS.ts","../node_modules/pixi.js/src/scene/text-html/HtmlTextStyle.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","../node_modules/pixi.js/src/utils/browser/isSafari.ts","../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","../node_modules/pixi.js/src/scene/text-html/init.ts","../node_modules/pixi.js/src/scene/text/TextStyle.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts","../node_modules/pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts","../node_modules/pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","../node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","../node_modules/pixi.js/src/scene/text/init.ts","../node_modules/pixi.js/src/scene/text/utils/generateTextStyleKey.ts","../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts","../node_modules/pixi.js/src/utils/data/ViewableBuffer.ts"],"sourcesContent":["\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPlugin}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n// eslint-disable-next-line max-len\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n// TODO could we cache local bounds on the render groups?\n\nconst tempMatrix = new Matrix();\n\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    _getGlobalBoundsRecursive(target, bounds);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    if (!target.renderGroup)\n    {\n        bounds.applyMatrix(target.parentRenderGroup.worldTransform);\n    }\n    else\n    {\n        bounds.applyMatrix(target.renderGroup.localTransform);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBoundsRecursive(\n    target: Container,\n    bounds: Bounds,\n)\n{\n    if (target.localDisplayStatus !== 0b111 || !target.measurable)\n    {\n        return;\n    }\n\n    const manageEffects = !!target.effects.length;\n\n    let localBounds = bounds;\n\n    if (target.renderGroup || manageEffects)\n    {\n        localBounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, target.worldTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            const viewBounds = (target as Renderable).bounds;\n\n            localBounds.addFrame(\n                viewBounds.minX,\n                viewBounds.minY,\n                viewBounds.maxX,\n                viewBounds.maxY,\n                target.groupTransform\n            );\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getGlobalBoundsRecursive(children[i], localBounds);\n        }\n    }\n\n    if (manageEffects)\n    {\n        let advanced = false;\n\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            if (target.effects[i].addBounds)\n            {\n                if (!advanced)\n                {\n                    advanced = true;\n                    localBounds.applyMatrix(target.parentRenderGroup.worldTransform);\n                }\n\n                target.effects[i].addBounds(localBounds, true);\n            }\n        }\n\n        if (advanced)\n        {\n            localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n\n        bounds.addBounds(localBounds);\n        boundsPool.return(localBounds);\n    }\n    else if (target.renderGroup)\n    {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        boundsPool.return(localBounds);\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? colorTextureSource._resolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= colorTextureSource.antialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        // need to factor in resolutions also..\n        bounds\n            .scale(resolution);\n\n        if (clipToViewport)\n        {\n            const viewPort = renderer.renderTarget.rootViewPort;\n\n            bounds.fitBounds(0, viewPort.width, 0, viewPort.height);\n        }\n\n        bounds\n            .ceil()\n            .scale(1 / resolution)\n            .pad(padding | 0);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        renderable.addBounds(bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import type { GlRenderingContext } from '../../../renderers/gl/context/GlRenderingContext';\n\nconst fragTemplate = [\n    'precision mediump float;',\n    'void main(void){',\n    'float test = 0.1;',\n    '%forloop%',\n    'gl_FragColor = vec4(0.0);',\n    '}',\n].join('\\n');\n\nfunction generateIfTestSrc(maxIfs: number): string\n{\n    let src = '';\n\n    for (let i = 0; i < maxIfs; ++i)\n    {\n        if (i > 0)\n        {\n            src += '\\nelse ';\n        }\n\n        if (i < maxIfs - 1)\n        {\n            src += `if(test == ${i}.0){}`;\n        }\n    }\n\n    return src;\n}\n\nexport function checkMaxIfStatementsInShader(maxIfs: number, gl: GlRenderingContext): number\n{\n    if (maxIfs === 0)\n    {\n        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');\n    }\n\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    try\n    {\n        while (true) // eslint-disable-line no-constant-condition\n        {\n            const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                maxIfs = (maxIfs / 2) | 0;\n            }\n            else\n            {\n                // valid!\n                break;\n            }\n        }\n    }\n    finally\n    {\n        gl.deleteShader(shader);\n    }\n\n    return maxIfs;\n}\n","import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader';\n\nlet maxTexturesPerBatchCache: number | null = null;\n\n/**\n * Returns the maximum number of textures that can be batched. This uses WebGL1's `MAX_TEXTURE_IMAGE_UNITS`.\n * The response for this is that to get this info via WebGPU, we would need to make a context, which\n * would make this function async, and we want to avoid that.\n * @private\n * @returns {number} The maximum number of textures that can be batched\n */\nexport function getMaxTexturesPerBatch(): number\n{\n    if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;\n\n    const gl = getTestContext();\n\n    // step 1: first check max textures the GPU can handle.\n    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n    // step 2: check the maximum number of if statements the shader can have too..\n    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n        maxTexturesPerBatchCache, gl);\n\n    gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n    return maxTexturesPerBatchCache;\n}\n","import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n","export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n","function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n","function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n                ${results\n        .sort()\n        .map((inValue) => ` ${extractVariableName(inValue)}`)\n        .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n","/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n","import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n","const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n        \n        {{end}}\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n","export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n","import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n","export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n","import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n","export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n","import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n","const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n","export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n","import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n","export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n","export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n","import { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst batchSamplersUniformGroupHash: Record<number, UniformGroup> = {};\n\n/**\n * Automatically generates a uniform group that holds the texture samplers for a shader.\n * This is used mainly by the shaders that batch textures!\n * @param maxTextures - the number of textures that this uniform group will contain.\n * @returns a uniform group that holds the texture samplers.\n */\nexport function getBatchSamplersUniformGroup(maxTextures: number)\n{\n    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n\n    if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n\n    const sampleValues = new Int32Array(maxTextures);\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n\n    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n        uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n    }, { isStatic: true });\n\n    return batchSamplersUniformGroup;\n}\n","import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @static\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n","import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @memberof rendering\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     * @ignore\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     * @ignore\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     * @ignore\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n","export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n","export enum ShaderStage\n    {\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is laid out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _attributeLocationsKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n","import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n","import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n","import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { BufferUsage } from './const';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\n\n/** All the various typed arrays that exist in js */\n// eslint-disable-next-line max-len\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n\n/** Options for creating a buffer */\nexport interface BufferOptions\n{\n    /**\n     * the data to initialize the buffer with, this can be a typed array,\n     * or a regular number array. If it is a number array, it will be converted to a Float32Array\n     */\n    data?: TypedArray | number[];\n    /** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n    size?: number;\n    /** the usage of the buffer, see {@link rendering.BufferUsage} */\n    usage: number;\n    /** a label for the buffer, this is useful for debugging */\n    label?: string;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    shrinkToFit?: boolean;\n}\n\nexport interface BufferDescriptor\n{\n    label?: string;\n    size: GPUSize64;\n    usage: BufferUsage;\n    mappedAtCreation?: boolean;\n}\n\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @memberof rendering\n */\nexport class Buffer extends EventEmitter<{\n    change: BindResource,\n    update: Buffer,\n    destroy: Buffer,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'buffer';\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * a description of the buffer and how it should be set up on the GPU\n     * @internal\n     * @ignore\n     */\n    public readonly descriptor: BufferDescriptor;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateID = 1;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateSize: number;\n\n    private _data: TypedArray;\n\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    public shrinkToFit = true;\n\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Creates a new Buffer with the given options\n     * @param options - the options for the buffer\n     */\n    constructor(options: BufferOptions)\n    {\n        let { data, size } = options;\n        const { usage, label, shrinkToFit } = options;\n\n        super();\n\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data as number[]);\n        }\n\n        this._data = data as TypedArray;\n\n        size = size ?? (data as TypedArray)?.byteLength;\n\n        const mappedAtCreation = !!data;\n\n        this.descriptor = {\n            size,\n            usage,\n            mappedAtCreation,\n            label,\n        };\n\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n\n    /** the data in the buffer */\n    get data()\n    {\n        return this._data;\n    }\n\n    set data(value: TypedArray)\n    {\n        this.setDataWithSize(value, value.length, true);\n    }\n\n    /** whether the buffer is static or not */\n    get static()\n    {\n        return !!(this.descriptor.usage & BufferUsage.STATIC);\n    }\n\n    set static(value: boolean)\n    {\n        if (value)\n        {\n            this.descriptor.usage |= BufferUsage.STATIC;\n        }\n        else\n        {\n            this.descriptor.usage &= ~BufferUsage.STATIC;\n        }\n    }\n\n    /**\n     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n     * If you only want to update a subset of the buffer, you can pass in the size of the data.\n     * @param value - the data to set\n     * @param size - the size of the data in bytes\n     * @param syncGPU - should the buffer be updated on the GPU immediately?\n     */\n    public setDataWithSize(value: TypedArray, size: number, syncGPU: boolean)\n    {\n        // Increment update ID\n        this._updateID++;\n\n        this._updateSize = (size * value.BYTES_PER_ELEMENT);\n\n        // If the data hasn't changed, early return after emitting 'update'\n        if (this._data === value)\n        {\n            if (syncGPU) this.emit('update', this);\n\n            return;\n        }\n\n        // Cache old data and update to new value\n        const oldData = this._data;\n\n        this._data = value;\n\n        // Event handling\n        if (oldData.length !== value.length)\n        {\n            if (!this.shrinkToFit && value.byteLength < oldData.byteLength)\n            {\n                if (syncGPU) this.emit('update', this);\n            }\n            else\n            {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = uid('resource');\n                this.emit('change', this);\n            }\n\n            return;\n        }\n\n        if (syncGPU) this.emit('update', this);\n    }\n\n    /**\n     * updates the buffer on the GPU to reflect the data in the buffer.\n     * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n     * you can pass in the size of the buffer to update.\n     * @param sizeInBytes - the new size of the buffer in bytes\n     */\n    public update(sizeInBytes?: number): void\n    {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n\n        this._updateID++;\n\n        this.emit('update', this);\n    }\n\n    /** Destroys the buffer */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this._data = null;\n        (this.descriptor as null) = null;\n\n        this.removeAllListeners();\n    }\n}\n\n","/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @memberof rendering\n */\nexport enum BufferUsage\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n     * May only be combined with COPY_DST.\n     */\n    MAP_READ = 0x0001,\n    /**\n     * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n     * May only be combined with COPY_SRC.\n     */\n    MAP_WRITE = 0x0002,\n    /**\n     * The buffer can be used as the source of a copy operation.\n     * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n     */\n    COPY_SRC = 0x0004,\n    /**\n     * The buffer can be used as the destination of a copy or write operation.\n     * (Examples: as the destination argument of a copyBufferToBuffer() or\n     * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n     */\n    COPY_DST = 0x0008,\n    /** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n    INDEX = 0x0010,\n    /** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n    VERTEX = 0x0020,\n    /**\n     * The buffer can be used as a uniform buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n     */\n    UNIFORM = 0x0040,\n    /**\n     * The buffer can be used as a storage buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n     */\n    STORAGE = 0x0080,\n    /**\n     * The buffer can be used as to store indirect command arguments.\n     * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n     */\n    INDIRECT = 0x0100,\n    /**\n     * The buffer can be used to capture query results.\n     * (Example: as the destination argument of a resolveQuerySet() call.)\n     */\n    QUERY_RESOLVE = 0x0200,\n    /** the buffer will not be updated frequently */\n    STATIC = 0x0400\n}\n","import { Buffer } from '../../buffer/Buffer';\nimport { BufferUsage } from '../../buffer/const';\n\nimport type { TypedArray } from '../../buffer/Buffer';\n\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @memberof rendering\n */\nexport function ensureIsBuffer(buffer: Buffer | TypedArray | number[], index: boolean): Buffer\n{\n    if (!(buffer instanceof Buffer))\n    {\n        let usage: number = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n\n        // its an array!\n        if (buffer instanceof Array)\n        {\n            if (index)\n            {\n                buffer = new Uint32Array(buffer);\n                usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n            }\n\n            else\n            {\n                buffer = new Float32Array(buffer);\n                usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n            }\n        }\n\n        buffer = new Buffer({\n            data: buffer,\n            label: index ? 'index-mesh-buffer' : 'vertex-mesh-buffer',\n            usage\n        });\n    }\n\n    return buffer;\n}\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { uid } from '../../../../utils/data/uid';\nimport { Buffer } from '../buffer/Buffer';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer';\nimport { getGeometryBounds } from './utils/getGeometryBounds';\n\nimport type { TypedArray } from '../buffer/Buffer';\nimport type { Topology, VertexFormat } from './const';\n\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n\n/**\n * The attribute data for a geometries attributes\n * @memberof rendering\n */\nexport interface Attribute\n{\n    /** the buffer that this attributes data belongs to */\n    buffer: Buffer;\n    /** the format of the attribute */\n    format?: VertexFormat;\n    /** the stride of the data in the buffer - in bytes*/\n    stride?: number;\n    /** the offset of the attribute from the buffer, defaults to 0 - in bytes*/\n    offset?: number;\n    /** is this an instanced buffer? (defaults to false) */\n    instance?: boolean;\n    /** the number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n    size?: number;\n    /**\n     * the starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     */\n    start?: number;\n    /**\n     * attribute divisor for instanced rendering. Note: this is a **WebGL-only** feature, the WebGPU renderer will\n     * issue a warning if one of the attributes has divisor set.\n     */\n    divisor?: number;\n}\n\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link rendering.Attribute} but allows for the buffer to be a typed or number array\n * @memberof rendering\n */\ntype AttributeOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]}\n| Buffer | TypedArray | number[];\n\nexport type AttributeOptions = Record<string, AttributeOption>;\n\n/**\n * the interface that describes the structure of the geometry\n * @memberof rendering\n */\nexport interface GeometryDescriptor\n{\n    /** an optional label to easily identify the geometry */\n    label?: string;\n    /** the attributes that make up the geometry */\n    attributes?: AttributeOptions;\n    /** optional index buffer for this geometry */\n    indexBuffer?: Buffer | TypedArray | number[];\n    /** the topology of the geometry, defaults to 'triangle-list' */\n    topology?: Topology;\n\n    instanceCount?: number;\n}\nfunction ensureIsAttribute(attribute: AttributeOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        };\n    }\n\n    (attribute as Attribute).buffer = ensureIsBuffer(attribute.buffer as Buffer | TypedArray | number[], false);\n\n    return attribute as Attribute;\n}\n\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @memberof rendering\n * @class\n */\nexport class Geometry extends EventEmitter<{\n    update: Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology;\n    /** The unique id of the geometry. */\n    public readonly uid: number = uid('geometry');\n    /** A record of the attributes of the geometry. */\n    public readonly attributes: Record<string, Attribute>;\n    /** The buffers that the attributes use */\n    public readonly buffers: Buffer[];\n    /** The index buffer of the geometry */\n    public indexBuffer: Buffer;\n\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the instance count of the geometry to draw */\n    public instanceCount = 1;\n\n    private readonly _bounds: Bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Create a new instance of a geometry\n     * @param options - The options for the geometry.\n     */\n    constructor(options: GeometryDescriptor = {})\n    {\n        super();\n\n        const { attributes, indexBuffer, topology } = options;\n\n        this.buffers = [];\n\n        this.attributes = {};\n\n        if (attributes)\n        {\n            for (const i in attributes)\n            {\n                this.addAttribute(i, attributes[i]);\n            }\n        }\n\n        this.instanceCount = options.instanceCount || 1;\n\n        if (indexBuffer)\n        {\n            this.addIndex(indexBuffer);\n        }\n\n        this.topology = topology || 'triangle-list';\n    }\n\n    protected onBufferUpdate(): void\n    {\n        this._boundsDirty = true;\n        this.emit('update', this);\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    public getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    public getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    public getBuffer(id: string): Buffer\n    {\n        return this.getAttribute(id).buffer;\n    }\n\n    /**\n     * Used to figure out how many vertices there are in this geometry\n     * @returns the number of vertices in the geometry\n     */\n    public getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n\n            // TODO use SIZE again like v7..\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Adds an attribute to the geometry.\n     * @param name - The name of the attribute to add.\n     * @param attributeOption - The attribute option to add.\n     */\n    public addAttribute(name: string, attributeOption: AttributeOption): void\n    {\n        const attribute = ensureIsAttribute(attributeOption);\n\n        const bufferIndex = this.buffers.indexOf(attribute.buffer);\n\n        if (bufferIndex === -1)\n        {\n            this.buffers.push(attribute.buffer);\n\n            // two events here - one for a resize (new buffer change)\n            // and one for an update (existing buffer change)\n            attribute.buffer.on('update', this.onBufferUpdate, this);\n            attribute.buffer.on('change', this.onBufferUpdate, this);\n        }\n        this.attributes[name] = attribute;\n    }\n\n    /**\n     * Adds an index buffer to the geometry.\n     * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n     */\n    public addIndex(indexBuffer: Buffer | TypedArray | number[]): void\n    {\n        this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n        this.buffers.push(this.indexBuffer);\n    }\n\n    /** Returns the bounds of the geometry. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        return getGeometryBounds(this, 'aPosition', this._bounds);\n    }\n\n    /**\n     * destroys the geometry.\n     * @param destroyBuffers - destroy the buffers associated with this geometry\n     */\n    public destroy(destroyBuffers = false): void\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n\n        if (destroyBuffers)\n        {\n            this.buffers.forEach((buffer) => buffer.destroy());\n        }\n\n        (this.attributes as null) = null;\n        (this.buffers as null) = null;\n        (this.indexBuffer as null) = null;\n        (this._bounds as null) = null;\n    }\n}\n","import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n","import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n","/* eslint-disable no-new */\nimport EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\nexport interface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\nexport interface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\nexport interface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            groups = {};\n            groupMap = {};\n\n            if (gpuProgram)\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            let bindTick = 0;\n\n            for (const i in resources)\n            {\n                if (nameHash[i]) continue;\n\n                // build out a dummy bind group..\n                if (!groups[99])\n                {\n                    groups[99] = new BindGroup();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                // Yes i know this is a little strange, but wil line up the shaders neatly\n                // basically we want to be driven by how webGPU does things.\n                // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n\n                bindTick++;\n            }\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n","// TODO add more types as required\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>'\n] as const;\n\n/** useful for checking if a type is supported - a map of supported types with a true value. */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\n/* eslint-disable quote-props */\nexport type UniformsSyncCallback = (...args: any[]) => void;\n","/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n","import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n","/* eslint-disable max-len */\nimport type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","/* eslint-disable @typescript-eslint/indent */\n/**\n * Various blend modes supported by Pixi\n * @memberof filters\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation'\n| 'min'\n| 'max';\n\n/**\n * The map of blend modes supported by Pixi\n * @memberof rendering\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @memberof rendering\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    INVERSE_MASK_ACTIVE = 3,\n    RENDERING_MASK_REMOVE = 4,\n    NONE = 5,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @memberof rendering\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n","import { type BLEND_MODES, BLEND_TO_NPM } from './const';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES\n{\n    if (textureSource.alphaMode === 'no-premultiply-alpha')\n    {\n        return (BLEND_TO_NPM[blendMode as keyof typeof BLEND_TO_NPM] || blendMode) as BLEND_MODES;\n    }\n\n    return blendMode;\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\nexport interface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @name CanvasPool\n * @memberof rendering\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const canvas = canvasAndContext.canvas;\n        const { width, height } = canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        canvasAndContext.context.clearRect(0, 0, width, height);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\nexport const CanvasPool = new CanvasPoolClass();\n","import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: true,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n","const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n","import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\n/**\n * @memberof rendering\n * @extends rendering.WebGLRenderer\n * @extends rendering.WebGPURenderer\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\n/**\n * @extends rendering.WebGLOptions\n * @extends rendering.WebGPUOptions\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/* eslint-disable @typescript-eslint/indent */\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter whether or not you want to do something\n * in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { RenderableGCSystem } from '../../../rendering/renderers/shared/texture/RenderableGCSystem';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderableGC: RenderableGCSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n\n        this.renderer.renderableGC.addManagedHash(this, '_graphicsBatchesHash');\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch._batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        graphics.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        if (this._graphicsBatchesHash[graphics.uid] === undefined)\n        {\n            // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n            graphics.on('destroyed', this._destroyRenderableBound);\n        }\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors';\n\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Graphics } from './Graphics';\n\nconst identityMatrix = new Matrix();\n/**\n * A batchable graphics object.\n * @ignore\n */\n\nexport class BatchableGraphics implements DefaultBatchableMeshElement\n{\n    public readonly packAsQuad = false;\n    public batcherName = 'default';\n\n    public texture: Texture;\n\n    public renderable: Graphics;\n    public indexOffset: number;\n    public indexSize: number;\n    public attributeOffset: number;\n    public attributeSize: number;\n    public baseColor: number;\n    public alpha: number;\n    public applyTransform = true;\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    public geometryData: { vertices: number[]; uvs: number[]; indices: number[]; };\n\n    get uvs()\n    {\n        return this.geometryData.uvs;\n    }\n\n    get positions()\n    {\n        return this.geometryData.vertices;\n    }\n\n    get indices()\n    {\n        return this.geometryData.indices;\n    }\n\n    get blendMode()\n    {\n        if (this.applyTransform)\n        {\n            return this.renderable.groupBlendMode;\n        }\n\n        return 'normal';\n    }\n    get color()\n    {\n        const rgb = this.baseColor;\n        const bgr = (rgb >> 16) | (rgb & 0xff00) | ((rgb & 0xff) << 16);\n        const renderable = this.renderable;\n\n        if (renderable)\n        {\n            return multiplyHexColors(bgr, renderable.groupColor)\n            + ((this.alpha * renderable.groupAlpha * 255) << 24);\n        }\n\n        return bgr + ((this.alpha * 255) << 24);\n    }\n\n    get transform()\n    {\n        return this.renderable?.groupTransform || identityMatrix;\n    }\n\n    public copyTo(gpuBuffer: BatchableGraphics)\n    {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n\n        gpuBuffer.attributeOffset = this.attributeOffset;\n        gpuBuffer.attributeSize = this.attributeSize;\n\n        gpuBuffer.baseColor = this.baseColor;\n        gpuBuffer.alpha = this.alpha;\n\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n    }\n\n    public reset()\n    {\n        this.applyTransform = true;\n        this.renderable = null;\n    }\n}\n","export function multiplyHexColors(color1: number, color2: number): number\n{\n    if (color1 === 0xFFFFFF || !color2) return color2;\n    if (color2 === 0xFFFFFF || !color1) return color1;\n\n    const r1 = (color1 >> 16) & 0xFF;\n    const g1 = (color1 >> 8) & 0xFF;\n    const b1 = color1 & 0xFF;\n\n    const r2 = (color2 >> 16) & 0xFF;\n    const g2 = (color2 >> 8) & 0xFF;\n    const b2 = color2 & 0xFF;\n\n    const r = (r1 * r2) / 255;\n    const g = (g1 * g2) / 255;\n    const b = (b1 * b2) / 255;\n\n    return (r << 16) + (g << 8) + b;\n}\n","import { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Circle object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @memberof maths\n */\nexport class Circle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this circle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this circle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The radius of the circle\n     *  @default 0\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'circle';\n\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    constructor(x = 0, y = 0, radius = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    /**\n     * Creates a clone of this Circle instance\n     * @returns A copy of the Circle\n     */\n    public clone(): Circle\n    {\n        return new Circle(this.x, this.y, this.radius);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.radius <= 0) return false;\n\n        const r2 = this.radius * this.radius;\n        let dx = (this.x - x);\n        let dy = (this.y - y);\n\n        dx *= dx;\n        dy *= dy;\n\n        return (dx + dy <= r2);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width - The width of the line to check\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public strokeContains(x: number, y: number, width: number): boolean\n    {\n        if (this.radius === 0) return false;\n\n        const dx = (this.x - x);\n        const dy = (this.y - y);\n        const r = this.radius;\n        const w2 = width / 2;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n        return (distance < r + w2 && distance > r - w2);\n    }\n\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another circle to this one.\n     * @param circle - The circle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(circle: Circle): this\n    {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n\n        return this;\n    }\n\n    /**\n     * Copies this circle to another one.\n     * @param circle - The circle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(circle: Circle): Circle\n    {\n        circle.copyFrom(this);\n\n        return circle;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * ```js\n * import { Ellipse } from 'pixi.js';\n *\n * const ellipse = new Ellipse(0, 0, 20, 10); // 40x20 rectangle\n * const isPointInEllipse = ellipse.contains(0, 0); // true\n * ```\n * @memberof maths\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance\n     * @returns {Ellipse} A copy of the ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public strokeContains(x: number, y: number, width: number): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const halfStrokeWidth = width / 2;\n        const innerA = halfWidth - halfStrokeWidth;\n        const innerB = halfHeight - halfStrokeWidth;\n        const outerA = halfWidth + halfStrokeWidth;\n        const outerB = halfHeight + halfStrokeWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerA * innerA))\n                           + ((normalizedY * normalizedY) / (innerB * innerB));\n        const outerEllipse = ((normalizedX * normalizedX) / (outerA * outerA))\n                           + ((normalizedY * normalizedY) / (outerB * outerB));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x - this.halfWidth;\n        out.y = this.y - this.halfHeight;\n        out.width = this.halfWidth * 2;\n        out.height = this.halfHeight * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @param ellipse - The ellipse to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @param ellipse - The ellipse to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n","export function squaredDistanceToLineSegment(\n    x: number, y: number,\n    x1: number, y1: number,\n    x2: number, y2: number\n): number\n{\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n\n    const dot = (a * c) + (b * d);\n    const lenSq = (c * c) + (d * d);\n    let param = -1;\n\n    if (lenSq !== 0)\n    {\n        param = dot / lenSq;\n    }\n\n    let xx; let\n        yy;\n\n    if (param < 0)\n    {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1)\n    {\n        xx = x2;\n        yy = y2;\n    }\n\n    else\n    {\n        xx = x1 + (param * c);\n        yy = y1 + (param * d);\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n\n    return (dx * dx) + (dy * dy);\n}\n","import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { PointData } from '../point/PointData';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * A class to define a shape via user defined coordinates.\n *\n *\n * `Polygon` can accept the following different constructor arguments:\n * - An array of `Point` objects\n * - An array of coordinate pairs\n *\n *\n * These can be passed as a single array, or as a sequence of arguments.\n * ```js\n * import { Polygon } from 'pixi.js';\n *\n * // create a polygon object from an array of points, or an array of coordinate pairs\n * const polygon1 = new Polygon([ new Point(0, 0), new Point(0, 100), new Point(100, 100) ]);\n * const polygon2 = new Polygon([ 0, 0, 0, 100, 100, 100 ]);\n *\n * // or create a polygon object from a sequence of points, or coordinate pairs\n * const polygon3 = new Polygon(new Point(0, 0), new Point(0, 100), new Point(100, 100));\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n * ```\n * @memberof maths\n */\nexport class Polygon implements ShapePrimitive\n{\n    /** An array of the points of this polygon. */\n    public points: number[];\n\n    /** `false` after moveTo, `true` after `closePath`. In all other cases it is `true`. */\n    public closePath: boolean;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'polygon';\n\n    constructor(points: PointData[] | number[]);\n    constructor(...points: PointData[] | number[]);\n    /**\n     * @param points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points: (PointData[] | number[])[] | PointData[] | number[])\n    {\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number')\n        {\n            const p: number[] = [];\n\n            for (let i = 0, il = flat.length; i < il; i++)\n            {\n                p.push((flat[i] as PointData).x, (flat[i] as PointData).y);\n            }\n\n            flat = p;\n        }\n\n        this.points = flat as number[];\n\n        this.closePath = true;\n    }\n\n    /**\n     * Creates a clone of this polygon.\n     * @returns - A copy of the polygon.\n     */\n    public clone(): Polygon\n    {\n        const points = this.points.slice();\n        const polygon = new Polygon(points);\n\n        polygon.closePath = this.closePath;\n\n        return polygon;\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this polygon.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this polygon\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number): boolean\n    {\n        const halfStrokeWidth = strokeWidth / 2;\n        const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n        const { points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n\n        for (let i = 0; i < iterationLength; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n\n            const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n\n            if (distanceSqrd <= halfStrokeWidthSqrd)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the framing rectangle of the polygon as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        const points = this.points;\n\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0, n = points.length; i < n; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        out.x = minX;\n        out.width = maxX - minX;\n\n        out.y = minY;\n        out.height = maxY - minY;\n\n        return out;\n    }\n\n    /**\n     * Copies another polygon to this one.\n     * @param polygon - The polygon to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(polygon: Polygon): this\n    {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n\n        return this;\n    }\n\n    /**\n     * Copies this polygon to another one.\n     * @param polygon - The polygon to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(polygon: Polygon): Polygon\n    {\n        polygon.copyFrom(this);\n\n        return polygon;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Polygon`\n            + `closeStroke=${this.closePath}`\n            + `points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, '')}]`;\n    }\n    // #endif\n\n    /**\n     * Get the last X coordinate of the polygon\n     * @readonly\n     */\n    get lastX(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon\n     * @readonly\n     */\n    get lastY(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n\n    /**\n     * Get the first X coordinate of the polygon\n     * @readonly\n     */\n    get x(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n    /**\n     * Get the first Y coordinate of the polygon\n     * @readonly\n     */\n    get y(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n}\n\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n// Check corner within stroke width\nconst isCornerWithinStroke = (\n    pX: number,\n    pY: number,\n    cornerX: number,\n    cornerY: number,\n    radius: number,\n    halfStrokeWidth: number\n) =>\n{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n    return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\n\n/**\n * The `RoundedRectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`, including a `radius` property that\n * defines the radius of the rounded corners.\n * @memberof maths\n */\nexport class RoundedRectangle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rounded rectangle\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rounded rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * Controls the radius of the rounded corners\n     * @default 20\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    public readonly type = 'roundedRectangle';\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n\n    /**\n     * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n\n        return out;\n    }\n\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @returns - A copy of the rounded rectangle.\n     */\n    public clone(): RoundedRectangle\n    {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: RoundedRectangle): this\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: RoundedRectangle): RoundedRectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width)\n        {\n            if (y >= this.y && y <= this.y + this.height)\n            {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                || (x >= this.x + radius && x <= this.x + this.width - radius))\n                {\n                    return true;\n                }\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param pX - The X coordinate of the point to test\n     * @param pY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(pX: number, pY: number, strokeWidth: number): boolean\n    {\n        const { x, y, width, height, radius } = this;\n\n        const halfStrokeWidth = strokeWidth / 2;\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - (radius * 2);\n        const innerHeight = height - (radius * 2);\n        const rightBound = x + width;\n        const bottomBound = y + height;\n\n        // Check if point is within the vertical edges (excluding corners)\n        if (((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth)\n             || (pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth))\n            && pY >= innerY && pY <= innerY + innerHeight)\n        {\n            return true;\n        }\n\n        // Check if point is within the horizontal edges (excluding corners)\n        if (((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth)\n             || (pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth))\n            && pX >= innerX && pX <= innerX + innerWidth)\n        {\n            return true;\n        }\n\n        // Top-left, top-right, bottom-right, bottom-left corners\n        return (\n            // Top-left\n            (pX < innerX && pY < innerY\n                && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth))\n            //  top-right\n            || (pX > rightBound - radius && pY < innerY\n                && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth))\n            // bottom-right\n            || (pX > rightBound - radius && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth))\n            // bottom-left\n            || (pX < innerX && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)));\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}`\n            + `width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n","// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n","export function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n","// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @memberof scene\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: { shape: ShapePrimitive, transform?: Matrix }[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n            // build out the path points\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (lastShape.transform && !lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n","import { buildArc } from './buildArc';\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n */\nexport function buildArcTo(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    radius: number,\n): void\n{\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n\n        return;\n    }\n\n    const dd = (a1 * a1) + (b1 * b1);\n    const cc = (a2 * a2) + (b2 * b2);\n    const tt = (a1 * a2) + (b1 * b2);\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = (k1 * b2) + (k2 * b1);\n    const cy = (k1 * a2) + (k2 * a1);\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n\n    buildArc(points,\n        (cx + x1),\n        (cy + y1),\n        radius,\n        startAngle,\n        endAngle,\n        b1 * a2 > b2 * a1\n    );\n}\n","import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n","import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    /** unique id for this graphics path */\n    public readonly uid: number = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     */\n    constructor(instructions?: string | PathInstruction[])\n    {\n        if (typeof instructions === 'string')\n        {\n            SVGToGraphicsPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n","/* eslint-disable no-console */\nimport parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { GraphicsPath } from '../path/GraphicsPath';\n\ninterface SubPath\n{\n    startX: number;\n    startY: number;\n}\n\n// TODO optimise and cache the paths?\nexport function SVGToGraphicsPath(svgPath: string, path: GraphicsPath): GraphicsPath\n{\n    const commands = parse(svgPath);\n\n    const subpaths: SubPath[] = [];\n    let currentSubPath: SubPath | null = null;\n\n    let lastX = 0;\n    let lastY = 0;\n\n    for (let i = 0; i < commands.length; i++)\n    {\n        const command = commands[i];\n        const type = command[0];\n        const data = command; // alias for 1-based referencing\n\n        switch (type)\n        {\n            case 'M':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'm':\n\n                lastX += data[1];\n                lastY += data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'H':\n                lastX = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'h':\n                lastX += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'V':\n                lastY = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'v':\n                lastY += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'L':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'l':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'C':\n\n                lastX = data[5];\n                lastY = data[6];\n\n                path.bezierCurveTo(\n                    data[1], data[2],\n                    data[3], data[4],\n                    lastX, lastY\n                );\n                break;\n            case 'c':\n                path.bezierCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                    lastX + data[5], lastY + data[6]\n                );\n\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case 'S':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.bezierCurveToShort(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 's':\n                path.bezierCurveToShort(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'Q':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.quadraticCurveTo(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 'q':\n                path.quadraticCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4]\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'T':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 't':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 'A':\n                lastX = data[6];\n                lastY = data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'a':\n                lastX += data[6];\n                lastY += data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'Z':\n            case 'z':\n                path.closePath();\n                if (subpaths.length > 0)\n                {\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath)\n                    {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    }\n                    else\n                    {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                // #if _DEBUG\n                warn(`Unknown SVG path command: ${type}`);\n                // #endif\n        }\n\n        if (type !== 'Z' && type !== 'z')\n        {\n            if (currentSubPath === null)\n            {\n                currentSubPath = { startX: lastX, startY: lastY };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n\n    return path;\n}\n","import { Color } from '../../../../color/Color';\nimport { GraphicsPath } from '../path/GraphicsPath';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillStyle, StrokeStyle } from '../FillTypes';\nimport type {\n    GraphicsContext,\n} from '../GraphicsContext';\n\ninterface Session\n{\n    context: GraphicsContext;\n    path: GraphicsPath;\n}\n\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    if (typeof svg === 'string')\n    {\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    const session = {\n        context: graphicsContext,\n        path: new GraphicsPath(),\n    };\n\n    renderChildren(svg, session, null, null);\n\n    return graphicsContext;\n}\n\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n            d = svg.getAttribute('d') as string;\n\n            graphicsPath = new GraphicsPath(d);\n\n            session.context.path(graphicsPath);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'circle':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            r = parseFloatAttribute(svg, 'r', 0);\n\n            session.context.ellipse(cx, cy, r, r);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'rect':\n            x = parseFloatAttribute(svg, 'x', 0);\n            y = parseFloatAttribute(svg, 'y', 0);\n\n            width = parseFloatAttribute(svg, 'width', 0);\n            height = parseFloatAttribute(svg, 'height', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'ellipse':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry); // , 0, Math.PI * 2);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'line':\n            x1 = parseFloatAttribute(svg, 'x1', 0);\n            y1 = parseFloatAttribute(svg, 'y1', 0);\n\n            x2 = parseFloatAttribute(svg, 'x2', 0);\n            y2 = parseFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, true);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, false);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        // children will cover these two..\n        case 'g':\n        case 'svg':\n            break;\n        default: {\n            // eslint-disable-next-line no-console\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n\nfunction parseFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n\nfunction parseStyle(svg: SVGElement): { strokeStyle: ConvertedStrokeStyle; fillStyle: ConvertedFillStyle }\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    let useFill = false;\n    let useStroke = false;\n\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i];\n\n            const [key, value] = stylePart.split(':');\n\n            switch (key)\n            {\n                case 'stroke':\n                    if (value !== 'none')\n                    {\n                        strokeStyle.color = Color.shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n\n                    break;\n                case 'stroke-width':\n                    strokeStyle.width = Number(value);\n                    break;\n                case 'fill':\n                    if (value !== 'none')\n                    {\n                        useFill = true;\n                        fillStyle.color = Color.shared.setValue(value).toNumber();\n                    }\n                    break;\n                case 'fill-opacity':\n                    fillStyle.alpha = Number(value);\n                    break;\n                case 'stroke-opacity':\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case 'opacity':\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    }\n    else\n    {\n        const stroke = svg.getAttribute('stroke');\n\n        if (stroke && stroke !== 'none')\n        {\n            useStroke = true;\n            strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n\n            strokeStyle.width = parseFloatAttribute(svg, 'stroke-width', 1);\n        }\n\n        const fill = svg.getAttribute('fill');\n\n        if (fill && fill !== 'none')\n        {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(fill).toNumber();\n        }\n    }\n\n    return {\n        strokeStyle: useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: useFill ? (fillStyle as ConvertedFillStyle) : null,\n    };\n}\n","/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillInput, StrokeInput } from './FillTypes';\nimport type { RoundedPoint } from './path/roundShape';\n\nconst tmpPoint = new Point();\n\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @memberof scene\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n}>\n{\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    /** unique id for this graphics context */\n    public readonly uid: number = uid('graphicsContext');\n    public dirty = true;\n    public batchMode: BatchMode = 'auto';\n    public instructions: GraphicsInstructions[] = [];\n    public customShader?: Shader;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillInput)\n    {\n        this._fillStyle = toFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillInput)\n    {\n        this._strokeStyle = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillInput): this\n    {\n        this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: StrokeInput): this\n    {\n        this._strokeStyle = toFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture, tint, and dimensions.\n     * If only a texture is provided, it uses the texture's width and height for drawing. Additional parameters allow for specifying\n     * a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint: ColorSource): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number, dw: number, dh: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillInput object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillInput, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: StrokeInput): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = toStrokeStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this._activePath.clear();\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        if (this.dirty) return;\n\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const padding = data.style.width / 2;\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - padding,\n                    _bounds.minY - padding,\n                    _bounds.maxX + padding,\n                    _bounds.maxY + padding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, (style as ConvertedStrokeStyle).width);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n     * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n","import { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\n\nimport type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\nconst cachedGroups: Record<number, BindGroup> = {};\n\nexport function getTextureBatchBindGroup(textures: TextureSource[], size: number)\n{\n    let uid = 2166136261; // FNV-1a 32-bit offset basis\n\n    for (let i = 0; i < size; i++)\n    {\n        uid ^= textures[i].uid;\n        uid = Math.imul(uid, 16777619);\n        uid >>>= 0;\n    }\n\n    return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);\n}\n\nlet maxTextures = 0;\n\nfunction generateTextureBatchBindGroup(textures: TextureSource[], size: number, key: number): BindGroup\n{\n    const bindGroupResources: Record<string, any> = {};\n\n    let bindIndex = 0;\n\n    if (!maxTextures)maxTextures = getMaxTexturesPerBatch();\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        const texture = i < size ? textures[i] : Texture.EMPTY.source;\n\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n\n    // pad out with empty textures\n    const bindGroup = new BindGroup(bindGroupResources);\n\n    cachedGroups[key] = bindGroup;\n\n    return bindGroup;\n}\n\n","/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void\n{\n    const lengthDouble = (sourceBuffer.byteLength / 8) | 0;\n\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n\n    // Use set for faster copying\n    destinationFloat64View.set(sourceFloat64View);\n\n    // copying over the remaining bytes\n    const remainingBytes = sourceBuffer.byteLength - (lengthDouble * 8);\n\n    if (remainingBytes > 0)\n    {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n\n        // Direct copy for remaining bytes\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n","import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @memberof rendering\n */\nexport class BatchTextureArray\n{\n    /** Inside textures array. */\n    public textures: TextureSource[];\n\n    /** Respective locations for textures. */\n    public ids: Record<number, number> = Object.create(null);\n\n    /** Number of filled elements. */\n    public count: number;\n\n    constructor()\n    {\n        this.textures = [];\n        this.count = 0;\n    }\n\n    /** Clear the textures and their locations. */\n    public clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            const t = this.textures[i];\n\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n\n        this.count = 0;\n    }\n}\n","import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\nimport { BatchTextureArray } from './BatchTextureArray';\n\nimport type { BoundsData } from '../../../scene/container/bounds/Bounds';\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { Geometry, IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray = new BatchTextureArray();\n\n    public blendMode: BLEND_MODES = 'normal';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\n// inlined pool for SPEEEEEEEEEED :D\nconst batchPool: Batch[] = [];\nlet batchPoolIndex = 0;\n\nfunction getBatchFromPool()\n{\n    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\n\nfunction returnBatchToPool(batch: Batch)\n{\n    batchPool[batchPoolIndex++] = batch;\n}\n\n/**\n * Represents an element that can be batched for rendering.\n * @interface\n * @memberof rendering\n */\nexport interface BatchableElement\n{\n    /**\n     * The name of the batcher to use. Must be registered.\n     * @type {string}\n     */\n    batcherName: string;\n\n    /**\n     * The texture to be used for rendering.\n     * @type {Texture}\n     */\n    texture: Texture;\n\n    /**\n     * The blend mode to be applied.\n     * @type {BLEND_MODES}\n     */\n    blendMode: BLEND_MODES;\n\n    /**\n     * The size of the index data.\n     * @type {number}\n     */\n    indexSize: number;\n\n    /**\n     * The size of the attribute data.\n     * @type {number}\n     */\n    attributeSize: number;\n\n    /**\n     * Whether the element should be packed as a quad for better performance.\n     * @type {boolean}\n     */\n    packAsQuad: boolean;\n\n    /**\n     * The texture ID, stored for efficient updating.\n     * @type {number}\n     * @private\n     */\n    _textureId: number;\n\n    /**\n     * The starting position in the attribute buffer.\n     * @type {number}\n     * @private\n     */\n    _attributeStart: number;\n\n    /**\n     * The starting position in the index buffer.\n     * @type {number}\n     * @private\n     */\n    _indexStart: number;\n\n    /**\n     * Reference to the batcher.\n     * @type {Batcher}\n     * @private\n     */\n    _batcher: Batcher;\n\n    /**\n     * Reference to the batch.\n     * @type {Batch}\n     * @private\n     */\n    _batch: Batch;\n}\n\n/**\n * Represents a batchable quad element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableQuadElement extends BatchableElement\n{\n    /**\n     * Indicates that this element should be packed as a quad.\n     * @type {true}\n     */\n    packAsQuad: true;\n\n    /**\n     * The size of the attribute data for this quad element.\n     * @type {4}\n     */\n    attributeSize: 4;\n\n    /**\n     * The size of the index data for this quad element.\n     * @type {6}\n     */\n    indexSize: 6;\n\n    /**\n     * The bounds data for this quad element.\n     * @type {BoundsData}\n     */\n    bounds: BoundsData;\n}\n\n/**\n * Represents a batchable mesh element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableMeshElement extends BatchableElement\n{\n    /**\n     * The UV coordinates of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    uvs: number[] | Float32Array;\n\n    /**\n     * The vertex positions of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    positions: number[] | Float32Array;\n\n    /**\n     * The indices of the mesh.\n     * @type {number[] | Uint16Array | Uint32Array}\n     */\n    indices: number[] | Uint16Array | Uint32Array;\n\n    /**\n     * The offset in the index buffer.\n     * @type {number}\n     */\n    indexOffset: number;\n\n    /**\n     * The offset in the attribute buffer.\n     * @type {number}\n     */\n    attributeOffset: number;\n\n    /**\n     * Indicates that this element should not be packed as a quad.\n     * @type {false}\n     */\n    packAsQuad: false;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @memberof rendering\n */\nexport interface BatcherOptions\n{\n    /** The maximum number of textures per batch. */\n    maxTextures?: number;\n    attributesInitialSize?: number;\n    indicesInitialSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * It is an abstract class that must be extended. see DefaultBatcher for an example.\n * @memberof rendering\n */\nexport abstract class Batcher\n{\n    public static defaultOptions: Partial<BatcherOptions> = {\n        maxTextures: null,\n        attributesInitialSize: 4,\n        indicesInitialSize: 6,\n    };\n\n    /** unique id for this batcher */\n    public readonly uid: number = uid('batcher');\n\n    /** The buffer containing attribute data for all elements in the batch. */\n    public attributeBuffer: ViewableBuffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    /** The current size of the attribute data in the batch. */\n    public attributeSize: number;\n\n    /** The current size of the index data in the batch. */\n    public indexSize: number;\n\n    /** The total number of elements currently in the batch. */\n    public elementSize: number;\n\n    /** The starting index of elements in the current batch. */\n    public elementStart: number;\n\n    /** Indicates whether the batch data has been modified and needs updating. */\n    public dirty = true;\n\n    /** The current index of the batch being processed. */\n    public batchIndex = 0;\n\n    /** An array of all batches created during the current rendering process. */\n    public batches: Batch[] = [];\n\n    private _elements: BatchableElement[] = [];\n\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    /** The maximum number of textures per batch. */\n    public readonly maxTextures: number;\n\n    /** The name of the batcher. Must be implemented by subclasses. */\n    public abstract name: string;\n    /** The vertex size of the batcher. Must be implemented by subclasses. */\n    protected abstract vertexSize: number;\n\n    /** The geometry used by this batcher. Must be implemented by subclasses. */\n    public abstract geometry: Geometry;\n\n    /**\n     * The shader used by this batcher. Must be implemented by subclasses.\n     * this can be shared by multiple batchers of the same type.\n     */\n    public abstract shader: Shader;\n\n    /**\n     * Packs the attributes of a BatchableMeshElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packAttributes(\n        element: BatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    /**\n     * Packs the attributes of a BatchableQuadElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packQuadAttributes(\n        element: BatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    constructor(options: BatcherOptions = {})\n    {\n        Batcher.defaultOptions.maxTextures = Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n\n        this.indexBuffer = new Uint16Array(indicesInitialSize);\n\n        this.maxTextures = maxTextures;\n    }\n\n    public begin()\n    {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n\n        for (let i = 0; i < this.batchIndex; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableElement)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject._indexStart = this.indexSize;\n        batchableObject._attributeStart = this.attributeSize;\n        batchableObject._batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.attributeSize) * this.vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableElement, texture: Texture): boolean\n    {\n        const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject._textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableElement)\n    {\n        this.dirty = true;\n\n        const attributeBuffer = this.attributeBuffer;\n\n        if (batchableObject.packAsQuad)\n        {\n            this.packQuadAttributes(\n                batchableObject as BatchableQuadElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n        else\n        {\n            this.packAttributes(\n                batchableObject as BatchableMeshElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        const elements = this._elements;\n\n        // length 0??!! (we broke without adding anything)\n        if (!elements[this.elementStart]) return;\n\n        let batch = getBatchFromPool();\n        let textureBatch = batch.textures;\n\n        textureBatch.clear();\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const indexBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n\n        const maxTextures = this.maxTextures;\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const breakRequired = blendMode !== adjustedBlendMode;\n\n            if (source._batchTick === BATCH_TICK && !breakRequired)\n            {\n                element._textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n\n                if (element.packAsQuad)\n                {\n                    this.packQuadAttributes(\n                        element as BatchableQuadElement,\n                        f32, u32,\n                        element._attributeStart, element._textureId\n                    );\n                    this.packQuadIndex(\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n                else\n                {\n                    this.packAttributes(\n                        element as BatchableMeshElement,\n                        f32, u32,\n                        element._attributeStart,\n                        element._textureId\n                    );\n                    this.packIndex(\n                        element as BatchableMeshElement,\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n\n                element._batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= maxTextures || breakRequired)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n\n                batch = getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n\n                ++BATCH_TICK;\n            }\n\n            element._textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element._batch = batch;\n\n            size += element.indexSize;\n\n            if (element.packAsQuad)\n            {\n                this.packQuadAttributes(\n                    element as BatchableQuadElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n                this.packQuadIndex(\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n            else\n            {\n                this.packAttributes(element as BatchableMeshElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n\n                this.packIndex(\n                    element as BatchableMeshElement,\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        // track for returning later!\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public packQuadIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public packIndex(element: BatchableMeshElement, indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = element.indices;\n        const size = element.indexSize;\n        const indexOffset = element.indexOffset;\n        const attributeOffset = element.attributeOffset;\n\n        for (let i = 0; i < size; i++)\n        {\n            indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n        }\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i]._batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n","import { Buffer } from '../../renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../renderers/shared/buffer/const';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\nexport class BatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 6;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 5 * 4,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n","import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../renderers/shared/shader/Shader';\n\n/**\n * DefaultShader is a specialized shader class designed for batch rendering.\n * It extends the base Shader class and provides functionality for handling\n * color, texture batching, and pixel rounding in both WebGL and WebGPU contexts.\n *\n * It is used by the default batcher\n * @extends Shader\n * @memberof rendering\n */\nexport class DefaultShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'batch',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                roundPixelsBitGl,\n            ]\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'batch',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                roundPixelsBit,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Batcher } from './Batcher';\nimport { BatchGeometry } from './BatchGeometry';\nimport { DefaultShader } from './DefaultShader';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { BatchableMeshElement, BatchableQuadElement } from './Batcher';\n\nlet defaultShader: Shader = null;\n\n/**\n * Represents the common elements for default batch rendering.\n * This interface defines the properties that are used by the DefaultBatcher\n * to render elements efficiently in a batch.\n * @memberof rendering\n */\nexport interface DefaultBatchElements\n{\n    /**\n     * The color of the element that will be multiplied with the texture color.\n     * This is typically represented as a 32-bit integer in RGBA format.\n     */\n    color: number;\n\n    /**\n     * Determines whether the element should be rounded to the nearest pixel.\n     * - 0: No rounding (default)\n     * - 1: Round to nearest pixel\n     * This can help with visual consistency, especially for pixel art styles.\n     */\n    roundPixels: 0 | 1;\n\n    /**\n     * The transform matrix of the element.\n     * This matrix represents the position, scale, rotation, and skew of the element.\n     */\n    transform: Matrix;\n}\n\n/**\n * Represents a batchable quad element with default batch properties.\n * @memberof rendering\n */\nexport interface DefaultBatchableQuadElement extends BatchableQuadElement, DefaultBatchElements {}\n\n/**\n * Represents a batchable mesh element with default batch properties.\n * @memberof rendering\n */\nexport interface DefaultBatchableMeshElement extends BatchableMeshElement, DefaultBatchElements {}\n\n/**\n * The default batcher is used to batch quads and meshes. This batcher will batch the following elements:\n * - tints\n * - roundPixels\n * - texture\n * - transform\n * @memberof rendering\n */\nexport class DefaultBatcher extends Batcher\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.Batcher,\n        ],\n        name: 'default',\n    } as const;\n\n    public geometry = new BatchGeometry();\n    public shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));\n\n    public name = DefaultBatcher.extension.name;\n\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    public vertexSize = 6;\n\n    /**\n     * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n     * @param element - The DefaultBatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packAttributes(\n        element: DefaultBatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const { positions, uvs } = element;\n\n        const argb = element.color;\n\n        const offset = element.attributeOffset;\n        const end = offset + element.attributeSize;\n\n        for (let i = offset; i < end; i++)\n        {\n            const i2 = i * 2;\n\n            const x = positions[i2];\n            const y = positions[(i2) + 1];\n\n            float32View[index++] = (a * x) + (c * y) + tx;\n            float32View[index++] = (d * y) + (b * x) + ty;\n\n            float32View[index++] = uvs[i2];\n            float32View[index++] = uvs[(i2) + 1];\n\n            uint32View[index++] = argb;\n            uint32View[index++] = textureIdAndRound;\n        }\n    }\n\n    /**\n     * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n     * @param element - The DefaultBatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packQuadAttributes(\n        element: DefaultBatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const texture = element.texture;\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = element.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = element.color;\n\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n}\n\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @memberof rendering\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset = offset || 0;\n    stride = stride || 2;\n    size = size || (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'circle',\n    },\n\n    build(shape: RoundedShape, points: number[])\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            return points;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return points;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return points;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return points;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n\nexport const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: 'ellipse' } };\nexport const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: 'roundedRectangle' } };\n","import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeAttributes } from '../FillTypes';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param _verticesStride\n * @param _verticesOffset\n * @param indices\n * @param _indicesOffset\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeAttributes,\n    flipAlignment: boolean,\n    closed: boolean,\n    // alignment:number,\n\n    vertices: number[],\n    _verticesStride: number,\n    _verticesOffset: number,\n\n    indices: number[],\n    _indicesOffset: number,\n\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n","import { default as earcut } from 'earcut';\n\nexport function triangulateWithHoles(\n    points: number[],\n    holes: number[],\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    indices: number[],\n    indicesOffset: number\n)\n{\n    const triangles = earcut(points, holes, 2);\n\n    if (!triangles)\n    {\n        return;\n    }\n\n    for (let i = 0; i < triangles.length; i += 3)\n    {\n        indices[indicesOffset++] = (triangles[i] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 1] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 2] + verticesOffset);\n    }\n\n    let index = verticesOffset * verticesStride;\n\n    for (let i = 0; i < points.length; i += 2)\n    {\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n\n        index += verticesStride;\n    }\n}\n\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\nconst emptyArray: number[] = [];\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'polygon',\n    },\n\n    build(shape: Polygon, points: number[]): number[]\n    {\n        for (let i = 0; i < shape.points.length; i++)\n        {\n            points[i] = shape.points[i];\n        }\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n        //  holes: number[],\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    },\n\n};\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'rectangle',\n    },\n\n    build(shape: Rectangle, points: number[]): number[]\n    {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        if (!(width >= 0 && height >= 0))\n        {\n            return points;\n        }\n\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        count += verticesStride;\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n\n        // triangle 2\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Triangle } from '../../../../maths/shapes/Triangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'triangle',\n    },\n\n    build(shape: Triangle, points: number[]): number[]\n    {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../FillTypes';\nimport type { GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { GraphicsPath } from '../path/GraphicsPath';\nimport type { ShapePath } from '../path/ShapePath';\n\nexport const shapeBuilders: Record<string, ShapeBuildCommand> = {};\n\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\n\nconst tempRect = new Rectangle();\n\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            }\n\n            addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    const points: number[] = [];\n\n    const build = shapeBuilders.rectangle;\n\n    const rect = tempRect;\n\n    const texture = data.image;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    build.build(rect, points);\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.baseColor = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle | ConvertedStrokeStyle,\n    hole: GraphicsPath,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = shapeBuilders[shape.type];\n\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (hole && lastIndex === i)\n            {\n                if (lastIndex !== 0)\n                {\n                    console.warn('[Pixi Graphics] only the last shape have be cut out');\n                }\n\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(hole.shapePath);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style as ConvertedStrokeStyle;\n\n            buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = style.matrix;\n\n            if (textureMatrix)\n            {\n                // todo can prolly do this before calculating uvs..\n                if (matrix)\n                {\n                    textureMatrix.append(matrix.clone().invert());\n                }\n\n                buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n            }\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.attributeOffset = vertOffset;\n        graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.baseColor = style.color;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(shape: ShapePath)\n{\n    if (!shape) return [];\n\n    const holePrimitives = shape.shapePrimitives;\n\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = shapeBuilders[holePrimitive.type] as ShapeBuildCommand;\n\n        holeBuilder.build(holePrimitive, holePoints);\n\n        holeArrays.push(holePoints);\n    }\n\n    return holeArrays;\n}\n","export type LineCap = 'butt' | 'round' | 'square';\nexport type LineJoin = 'round' | 'bevel' | 'miter';\n\nexport const closePointEps = 1e-4;\nexport const curveEps = 0.0001;\n","export function getOrientationOfPoints(points: number[]): number\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return 1;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if (area < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @memberof rendering\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsContext\n{\n    public isBatchable: boolean;\n    public context: GraphicsContext;\n\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public batcher: Batcher = new DefaultBatcher();\n    public instructions = new InstructionSet();\n\n    public init()\n    {\n        this.instructions.reset();\n    }\n\n    /**\n     * @deprecated since version 8.0.0\n     * Use `batcher.geometry` instead.\n     * @see {Batcher#geometry}\n     */\n    get geometry()\n    {\n        // eslint-disable-next-line max-len\n        deprecation(v8_3_4, 'GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.');\n\n        return this.batcher.geometry;\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @memberof rendering\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @memberof rendering\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    private _gpuContextHash: Record<number, GpuGraphicsContext> = {};\n    // used for non-batchable graphics\n    private _graphicsDataContextHash: Record<number, GraphicsContextRenderData> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        renderer.renderableGC.addManagedHash(this, '_gpuContextHash');\n        renderer.renderableGC.addManagedHash(this, '_graphicsDataContextHash');\n    }\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n\n    // Context management functions\n    public updateGpuContext(context: GraphicsContext)\n    {\n        let gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid]\n\n            || this._initContext(context);\n\n        if (context.dirty)\n        {\n            if (gpuContext)\n            {\n                this._cleanGraphicsContextData(context);\n            }\n            else\n            {\n                gpuContext = this._initContext(context);\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData);// ();\n\n        const { batches, geometryData } = this._gpuContextHash[context.uid];\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = graphicsData.batcher;\n\n        // TODO we can pool buffers here eventually..\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = batcher.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n        }\n\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        gpuContext.context = context;\n\n        this._gpuContextHash[context.uid] = gpuContext;\n\n        context.on('destroy', this.onGraphicsContextDestroy, this);\n\n        return this._gpuContextHash[context.uid];\n    }\n\n    protected onGraphicsContextDestroy(context: GraphicsContext)\n    {\n        this._cleanGraphicsContextData(context);\n\n        context.off('destroy', this.onGraphicsContextDestroy, this);\n\n        this._gpuContextHash[context.uid] = null;\n    }\n\n    private _cleanGraphicsContextData(context: GraphicsContext)\n    {\n        const gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid];\n\n        if (!gpuContext.isBatchable)\n        {\n            if (this._graphicsDataContextHash[context.uid])\n            {\n                BigPool.return(this.getContextRenderData(context) as PoolItem);\n\n                // we will rebuild this...\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n\n        if (gpuContext.batches)\n        {\n            gpuContext.batches.forEach((batch) =>\n            {\n                BigPool.return(batch as PoolItem);\n            });\n        }\n    }\n\n    public destroy()\n    {\n        // Clean up all graphics contexts\n\n        for (const i in this._gpuContextHash)\n        {\n            if (this._gpuContextHash[i])\n            {\n                this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n            }\n        }\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { ColorSource } from '../../../../color/Color';\n\nexport type GradientType = 'linear' | 'radial';\n\n// export type GradientSource =\n//     string // CSS gradient string: 'linear-gradient(...)'\n//     | IGradientOptions // Gradient options: { x0, y0, x1, y1, ...}\n//     | Gradient; // class Gradient itself\n\nexport interface LinearGradientFillStyle\n{\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    colors: number[];\n    stops: number[];\n}\n\nexport class FillGradient implements CanvasGradient\n{\n    public static defaultTextureSize = 256;\n\n    /** unique id for this fill gradient */\n    public readonly uid: number = uid('fillGradient');\n    public readonly type: GradientType = 'linear';\n\n    public x0: number;\n    public y0: number;\n    public x1: number;\n    public y1: number;\n\n    public texture: Texture;\n    public transform: Matrix;\n    public gradientStops: Array<{ offset: number, color: string }> = [];\n\n    private _styleKey: string | null = null;\n\n    constructor(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.x0 = x0;\n        this.y0 = y0;\n\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n\n    public addColorStop(offset: number, color: ColorSource): this\n    {\n        this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n        this._styleKey = null;\n\n        return this;\n    }\n\n    // TODO move to the system!\n    public buildLinearGradient(): void\n    {\n        const defaultSize = FillGradient.defaultTextureSize;\n\n        const { gradientStops } = this;\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = defaultSize;\n        canvas.height = defaultSize;\n\n        const ctx = canvas.getContext('2d');\n\n        const gradient = ctx.createLinearGradient(0, 0, FillGradient.defaultTextureSize, 1);\n\n        for (let i = 0; i < gradientStops.length; i++)\n        {\n            const stop = gradientStops[i];\n\n            gradient.addColorStop(stop.offset, stop.color);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, defaultSize, defaultSize);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressModeU: 'clamp-to-edge',\n                addressModeV: 'repeat',\n            }),\n        });\n\n        // generate some UVS based on the gradient direction sent\n\n        const { x0, y0, x1, y1 } = this;\n\n        const m = new Matrix();\n\n        // get angle\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n\n        const dist = Math.sqrt((dx * dx) + (dy * dy));\n\n        const angle = Math.atan2(dy, dx);\n\n        m.translate(-x0, -y0);\n        m.scale(1 / defaultSize, 1 / defaultSize);\n        m.rotate(-angle);\n        m.scale(256 / dist, 1);\n\n        this.transform = m;\n        this._styleKey = null;\n    }\n\n    public get styleKey(): string\n    {\n        if (this._styleKey)\n        {\n            return this._styleKey;\n        }\n\n        const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join('-');\n        const texture = this.texture.uid;\n        const transform = this.transform.toArray().join('-');\n\n        return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\n\nexport type PatternRepetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n\nconst repetitionMap = {\n    repeat: {\n        addressModeU: 'repeat',\n        addressModeV: 'repeat',\n    },\n    'repeat-x': {\n        addressModeU: 'repeat',\n        addressModeV: 'clamp-to-edge',\n    },\n    'repeat-y': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'repeat',\n    },\n    'no-repeat': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n    },\n};\n\nexport class FillPattern implements CanvasPattern\n{\n    /** unique id for this fill pattern */\n    public readonly uid: number = uid('fillPattern');\n    public texture: Texture;\n    public transform = new Matrix();\n\n    private _styleKey: string | null = null;\n\n    constructor(texture: Texture, repetition?: PatternRepetition)\n    {\n        this.texture = texture;\n\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        if (repetition)\n        {\n            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU as WRAP_MODE;\n            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV as WRAP_MODE;\n        }\n    }\n\n    public setTransform(transform?: Matrix): void\n    {\n        const texture = this.texture;\n\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        //  transform.scale\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        this._styleKey = null;\n    }\n\n    public get styleKey(): string\n    {\n        if (this._styleKey) return this._styleKey;\n\n        this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join('-')}`;\n\n        return this._styleKey;\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n} from '../FillTypes';\n\nfunction isColorLike(value: unknown): value is ColorSource\n{\n    return Color.isColorLike(value as ColorSource);\n}\n\nfunction isFillPattern(value: unknown): value is FillPattern\n{\n    return value instanceof FillPattern;\n}\n\nfunction isFillGradient(value: unknown): value is FillGradient\n{\n    return value instanceof FillGradient;\n}\n\n/**\n * Handles the case where the value is a ColorLike\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(0xff0000)\n * graphics.fill(new Color(0xff0000))\n * graphics.fill({ r: 255, g: 0, b: 0 })\n */\nfunction handleColorLike(\n    fill: FillStyle,\n    value: ColorSource,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    const temp = Color.shared.setValue(value ?? 0);\n\n    fill.color = temp.toNumber();\n    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n    fill.texture = Texture.WHITE;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillPattern\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillPattern(0xff0000))\n */\nfunction handleFillPattern(\n    fill: FillStyle,\n    value: FillPattern,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillGradient\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillGradient(0, 0, 200, 0))\n */\nfunction handleFillGradient(\n    fill: FillStyle,\n    value: FillGradient,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    value.buildLinearGradient();\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is not a direct Pixi Color, PatternFill, or GradientFill but instead\n * an object with potentially `color`\n * @example\n * {\n *   color: new Color(0xff0000)\n *   alpha: 0.5,\n *   texture?: null,\n *   matrix?: null,\n * }\n * @param value\n * @param defaultStyle\n */\nfunction handleFillObject(value: FillStyle, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    const style = { ...defaultStyle, ...(value as FillStyle) };\n\n    if (style.texture)\n    {\n        if (style.texture !== Texture.WHITE)\n        {\n            const m = style.matrix?.invert() || new Matrix();\n\n            m.translate(style.texture.frame.x, style.texture.frame.y);\n            m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n\n            style.matrix = m;\n        }\n\n        const sourceStyle = style.texture.source.style;\n\n        if (sourceStyle.addressMode === 'clamp-to-edge')\n        {\n            sourceStyle.addressMode = 'repeat';\n            sourceStyle.update();\n        }\n    }\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null; // todo: lets optimise this!\n\n    return style as ConvertedFillStyle;\n}\n\n/**\n * Converts a value to a fill style, we do this as PixiJS has a number of ways to define a fill style\n * They can be a direct color, a texture, a gradient, or an object with these values in them\n * This function will take any of these input types and convert them into a single object\n * that PixiJS can understand and use internally.\n * @param value - The value to convert to a fill style\n * @param defaultStyle - The default fill style to use\n * @private\n */\nexport function toFillStyle<T extends FillInput>(\n    value: T,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    const fill: ConvertedFillStyle = {} as ConvertedFillStyle;\n    const objectStyle = value as FillStyle;\n\n    if (isColorLike(value))\n    {\n        return handleColorLike(fill, value, defaultStyle);\n    }\n    else if (isFillPattern(value))\n    {\n        return handleFillPattern(fill, value, defaultStyle);\n    }\n    else if (isFillGradient(value))\n    {\n        return handleFillGradient(fill, value, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillPattern(objectStyle.fill))\n    {\n        return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillGradient(objectStyle.fill))\n    {\n        return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n    }\n\n    return handleFillObject(objectStyle, defaultStyle);\n}\n\n/**\n * Converts a value to a stroke style, similar to `toFillStyle` but for strokes\n * @param value - The value to convert to a stroke style\n * @param defaultStyle - The default stroke style to use\n * @private\n */\nexport function toStrokeStyle(value: StrokeInput, defaultStyle: ConvertedStrokeStyle): ConvertedStrokeStyle\n{\n    const { width, alignment, miterLimit, cap, join, ...rest } = defaultStyle;\n    const fill = toFillStyle(value, rest);\n\n    if (!fill)\n    {\n        return null;\n    }\n\n    return {\n        width,\n        alignment,\n        miterLimit,\n        cap,\n        join,\n        ...fill,\n    };\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\n// eslint-disable-next-line max-len\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n\n        renderer.renderableGC.addManagedHash(this, '_gpuBatchableMeshHash');\n        renderer.renderableGC.addManagedHash(this, '_meshDataHash');\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            const texture = mesh.texture;\n\n            if (batchableMesh.texture._source !== texture._source)\n            {\n                if (batchableMesh.texture._source !== texture._source)\n                {\n                    return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, texture);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n\n        mesh.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', this._destroyRenderableBound);\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n    private _textureMatrixUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n","import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPop.state;\n        const renderer = particleContainerPop.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPop.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPop.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPop.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n","/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer = outBuffer || new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer = outBuffer || new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n","import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n      \n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @property {number} size - The size of the particle buffer.\n * @property {Record<string, ParticleRendererProperty>} properties - A record of attributes that the particle container uses.\n */\nexport interface ParticleBufferOptions\n{\n    size: number;\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../../container/Container';\nimport type { ParticleContainer } from './ParticleContainer';\n\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @memberof scene\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    public adaptor: ParticleContainerAdaptor;\n    public readonly state = State.for2d();\n    public readonly renderer: Renderer;\n\n    private _gpuBufferHash: Record<number, ParticleBuffer> = Object.create(null);\n    // eslint-disable-next-line max-len\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as unknown as (renderable: Container) => void;\n\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return this._gpuBufferHash[renderable.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        this._gpuBufferHash[renderable.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        renderable.on('destroyed', this._destroyRenderableBound);\n\n        return this._gpuBufferHash[renderable.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n\n    }\n\n    public destroyRenderable(renderable: ParticleContainer)\n    {\n        const buffer = this._gpuBufferHash[renderable.uid];\n\n        buffer.destroy();\n\n        this._gpuBufferHash[renderable.uid] = null;\n\n        renderable.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n","import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPop.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPop.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPop.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPop.state;\n\n        const buffer = particleContainerPop.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPop.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe';\n\n// NOTE: this is the first occurrence of needing both gl and gpu pipes in the same file\n// This could cause some issues with tree shaking in the future.\n// Right now these two files do not import anything specific for a renderer, so is not an issue for now.\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const positions = this.positions;\n\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1.0 : this.width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1.0 : this.height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - (this._bottomHeight * scale);\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - (this._rightWidth * scale);\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuSpriteHash');\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (gpuSprite.texture._source !== texture._source)\n        {\n            return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, texture);\n        }\n\n        return false;\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableMesh = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableMesh.geometry as PoolItem);\n        BigPool.return(batchableMesh as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n\n        sprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = BigPool.get(BatchableMesh);\n\n        batchableMesh.geometry = BigPool.get(NineSliceGeometry);\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // if the sprite has not been updated by the view, we need to update the batchable mesh now.\n        if (!sprite.didViewUpdate)\n        {\n            this._updateBatchableSprite(sprite, batchableMesh);\n        }\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', this._destroyRenderableBound);\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Container } from '../container/Container';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_tilingSpriteDataHash');\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            // we are batching.. check a texture change!\n            if (batchableMesh && batchableMesh.texture._source !== renderable.texture._source)\n            {\n                return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n            }\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n\n        tilingSprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', this._destroyRenderableBound);\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite._applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { ViewContainer } from '../view/ViewContainer';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: ViewContainer;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer } from '../../view/ViewContainer';\nimport { GraphicsContext } from './GraphicsContext';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillInput, FillStyle, StrokeStyle } from './FillTypes';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for `Graphics` instances.\n * ```js\n * const graphics = new Graphics({\n *    fillStyle: { color: 0xff0000, alpha: 0.5 },\n *    strokeStyle: { color: 0x00ff00, width: 2 },\n * });\n * ```\n * @see {@link scene.Graphics}\n * @memberof scene\n */\nexport interface GraphicsOptions extends ContainerOptions\n{\n    /** The GraphicsContext to use, useful for reuse and optimisation */\n    context?: GraphicsContext;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n * @memberof scene\n * @extends scene.Container\n */\nexport class Graphics extends ViewContainer implements Instruction\n{\n    public override readonly renderPipeId: string = 'graphics';\n    public batched: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphic.\n     * @type {rendering.Bounds}\n     */\n    override get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this._context.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n     * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n     * @param {boolean} [options.context=false] - Should destroy the context\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n     * pattern object, or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     * or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyle object for advanced fills.\n     * @param {FillInput} style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a\n     * complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha?: number): this;\n    public fill(...args: [FillStyle | ColorSource, number?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n     * complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise\n     * (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction.\n     * If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified,\n     * the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * The fill style to use.\n     * @type {ConvertedFillStyle}\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillInput)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * The stroke style to use.\n     * @type {ConvertedStrokeStyle}\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: StrokeStyle)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object.\n     * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n     * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n     * will be shared between the two objects (default false). If true, the context will be\n     * cloned (recommended if you need to modify the context in any way).\n     * @returns - A clone of the graphics object\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        color && (fillStyle.color = color);\n        alpha && (fillStyle.alpha = alpha);\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n","export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n             \n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);  \n              \n                return coverage;\n            }\n        `,\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = getMaxTexturesPerBatch();\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @memberof text */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @memberof text\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @memberof text\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @memberof text\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    public applyFillAsTint = true;\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            // texture may not exist if the char is \" \", \\n, \\r, or \\t.\n            this.chars[i].texture?.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n","/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\n\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n","import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { TextStyle } from '../text/TextStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n    textureSize?: number\n    mipmap?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    public static defaultOptions: DynamicBitmapFontOptions = {\n        textureSize: 512,\n        style: new TextStyle(),\n        mipmap: true,\n    };\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 0;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n    private readonly _textureSize: number;\n    private readonly _mipmap: boolean;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = { ...DynamicBitmapFont.defaultOptions, ...options };\n\n        this._textureSize = dynamicOptions.textureSize;\n        this._mipmap = dynamicOptions.mipmap;\n\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        this.applyFillAsTint = dynamicOptions.overrideFill;\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * metrics.width);\n\n            // override the line height.. we want this to be the glyps height\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = metrics.width * fontScale;\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = textureGlyphWidth + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > this._textureSize)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > this._textureSize)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n            this._textureSize,\n            this._textureSize,\n            textureResolution\n        );\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload',\n                autoGenerateMipmaps: this._mipmap,\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n","import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\nexport function getBitmapTextLayout(\n    chars: string[],\n    style: TextStyle,\n    font: AbstractBitmapFont<any>,\n    trimEnd: boolean\n): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n\n        if (trimEnd)\n        {\n            let lastChar = currentLine.chars[index];\n\n            while (lastChar === ' ')\n            {\n                currentLine.width -= font.chars[lastChar].xAdvance;\n                lastChar = currentLine.chars[--index];\n            }\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord\n                && style.wordWrap\n                && (currentLine.width + currentWord.width - adjustedLetterSpacing) > adjustedWordWrapWidth;\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\nlet fontCount = 0;\n\n/**\n *\n * The options for installing a new BitmapFont. Once installed the font will be available for use in the BitmapText.\n * It can be accessed by the `fontFamily` property of the TextStyle.\n *\n * Install a new BitmapFont will create the characters provided for the font and store them in the cache.\n * But don't worry, if a character is requested that hasn't been generated yet, it will be created on the fly.\n * @memberof text\n */\nexport interface BitmapFontInstallOptions\n{\n    /** the name of the font, this will be the name you use in the fontFamily of text style to access this font */\n    name?: string;\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * If true, this could potentially increase the performance, but may impact the rendered text appearance.\n     * @default false\n     */\n    skipKerning?: boolean;\n    /** Style options to render with BitmapFont. */\n    style?: TextStyle | TextStyleOptions;\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @memberof text\n * @name BitmapFontManager\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n    };\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill && !style._stroke)\n        {\n            fontFamilyKey += style._fill.fill.styleKey;\n            overrideFill = false;\n        }\n        else if (style._stroke || style.dropShadow)\n        {\n            // if there is a stoke, we need to use the style key as this the font generated cannot be tinted\n            // due to the fact the font has at least two colors.\n            let key = style.styleKey;\n\n            // remove the font size..\n            key = key.substring(0, key.lastIndexOf('-'));\n\n            fontFamilyKey = `${key}-bitmap`;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const fnt = new DynamicBitmapFont({\n                style,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fontCount++;\n\n            // warn users if they have created too many dynamic fonts\n            if (fontCount > 50)\n            {\n                // eslint-disable-next-line max-len\n                warn('BitmapText', `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n            }\n\n            fnt.once('destroy', () =>\n            {\n                fontCount--;\n                Cache.remove(fontFamilyKey);\n            });\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public getLayout(text: string, style: TextStyle, trimEnd: boolean = true): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        return getBitmapTextLayout([...text], style, bitmapFont, trimEnd);\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public measureText(\n        text: string,\n        style: TextStyle,\n        trimEnd: boolean = true\n    ): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style, trimEnd);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== undefined;\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            font.destroy();\n        }\n    }\n}\n\nexport const BitmapFontManager = new BitmapFontManagerClass();\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBitmapText');\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        bitmapText.off('destroyed', this._destroyRenderableBound);\n\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        const context = this._gpuBitmapText[renderableUid].context;\n\n        if (context.customShader)\n        {\n            BigPool.return(context.customShader as PoolItem);\n\n            context.customShader = null;\n        }\n\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                context.customShader = BigPool.get(SdfShader);\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', this._destroyRenderableBound);\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Container } from '../container/Container';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HtmlTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.resolutionChange.add(this);\n        this._renderer.renderableGC.addManagedHash(this, '_gpuText');\n    }\n\n    public resolutionChange()\n    {\n        for (const i in this._gpuText)\n        {\n            const gpuText = this._gpuText[i];\n\n            if (!gpuText) continue;\n\n            const text = gpuText.batchableSprite.renderable as HTMLText;\n\n            if (text._autoResolution)\n            {\n                text._resolution = this._renderer.resolution;\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite._batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        htmlText.off('destroyed', this._destroyRenderableBound);\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.transform = htmlText.groupTransform;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        this._gpuText[htmlText.uid] = gpuTextData;\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', this._destroyRenderableBound);\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\nexport const nssvg = 'http://www.w3.org/2000/svg';\nexport const nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HtmlTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: ConvertedStrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillInput, StrokeInput } from '../graphics/shared/FillTypes';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends {@link TextStyle}.\n * @memberof text\n * @extends text.TextStyleOptions\n * @property {string[]} [cssOverrides] - CSS style(s) to add.\n * @property {Record<string, text.HTMLTextStyleOptions>} [tagStyles] - Tag styles.\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' >\n{\n    cssOverrides?: string[];\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @memberof text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * List of styles per tag.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides ??= options.cssOverrides;\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /** List of style overrides that will be applied to the HTML text. */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    protected override _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join('-');\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * @returns New cloned HTMLTextStyle object\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n        });\n    }\n\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    override set fill(value: FillInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    override set stroke(value: StrokeInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: style.fontWeight,\n                        fontStyle: style.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding,\n    };\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HtmlTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: HTMLImageElement | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport {\n    toFillStyle,\n    toStrokeStyle\n} from '../graphics/shared/utils/convertFillInputToFillStyle';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n    StrokeStyle\n} from '../graphics/shared/FillTypes';\n\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n// eslint-disable-next-line max-len\nexport type TextStyleFontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * A collection of text related classes.\n * @namespace text\n */\n\n/**\n * A drop shadow effect.\n * @memberof text\n */\nexport type TextDropShadow = {\n    /** Set alpha for the drop shadow  */\n    alpha: number;\n    /** Set a angle of the drop shadow */\n    angle: number;\n    /** Set a shadow blur radius */\n    blur: number;\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n    color: ColorSource;\n    /** Set a distance of the drop shadow */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances.\n * ```js\n * const textStyle = new TextStyle({\n *    fontSize: 12,\n *    fill: 'black',\n * });\n * ```\n * @see {@link text.TextStyle}\n * @memberof text\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    align?: TextStyleAlign;\n    /** Indicates if lines can be wrapped within words, it needs `wordWrap` to be set to `true` */\n    breakWords?: boolean;\n    /** Set a drop shadow for the text */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.\n     * Can be an array to create a gradient, e.g., `['#000000','#FFFFFF']`\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    fill?: FillInput;\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    fontFamily?: string | string[];\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    fontSize?: number | string;\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /** A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00' */\n    stroke?: StrokeInput;\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    textBaseline?: TextStyleTextBaseline;\n    trim?: boolean,\n    /**\n     * Determines whether newlines & spaces are collapsed or preserved \"normal\"\n     * (collapse, collapse), \"pre\" (preserve, preserve) | \"pre-line\" (preserve,\n     * collapse). It needs wordWrap to be set to true.\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n}\n\n/**\n * A TextStyle Object contains information to decorate a Text objects.\n *\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @memberof text\n * @example\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *   fontSize: 36,\n * });\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /** The default drop shadow settings */\n    public static defaultDropShadow: TextDropShadow = {\n        /** Set alpha for the drop shadow */\n        alpha: 1,\n        /** Set a angle of the drop shadow */\n        angle: Math.PI / 6,\n        /** Set a shadow blur radius */\n        blur: 0,\n        /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n        color: 'black',\n        /** Set a distance of the drop shadow */\n        distance: 5,\n    };\n\n    /** The default text style settings */\n    public static defaultTextStyle: TextStyleOptions = {\n        /**\n         * See {@link TextStyle.align}\n         * @type {'left'|'center'|'right'|'justify'}\n         */\n        align: 'left',\n        /** See {@link TextStyle.breakWords} */\n        breakWords: false,\n        /** See {@link TextStyle.dropShadow} */\n        dropShadow:  null,\n        /**\n         * See {@link TextStyle.fill}\n         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n         */\n        fill: 'black',\n        /**\n         * See {@link TextStyle.fontFamily}\n         * @type {string|string[]}\n         */\n        fontFamily: 'Arial',\n        /**\n         * See {@link TextStyle.fontSize}\n         * @type {number|string}\n         */\n        fontSize: 26,\n        /**\n         * See {@link TextStyle.fontStyle}\n         * @type {'normal'|'italic'|'oblique'}\n         */\n        fontStyle: 'normal',\n        /**\n         * See {@link TextStyle.fontVariant}\n         * @type {'normal'|'small-caps'}\n         */\n        fontVariant: 'normal',\n        /**\n         * See {@link TextStyle.fontWeight}\n         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n         */\n        fontWeight: 'normal',\n        /** See {@link TextStyle.leading} */\n        leading: 0,\n        /** See {@link TextStyle.letterSpacing} */\n        letterSpacing: 0,\n        /** See {@link TextStyle.lineHeight} */\n        lineHeight: 0,\n        /** See {@link TextStyle.padding} */\n        padding: 0,\n        /**\n         * See {@link TextStyle.stroke}\n         * @type {string|number}\n         */\n        stroke: null,\n        /**\n         * See {@link TextStyle.textBaseline}\n         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n         */\n        textBaseline: 'alphabetic',\n        /** See {@link TextStyle.trim} */\n        trim: false,\n        /**\n         * See {@link TextStyle.whiteSpace}\n         * @type {'normal'|'pre'|'pre-line'}\n         */\n        whiteSpace: 'pre',\n        /** See {@link TextStyle.wordWrap} */\n        wordWrap: false,\n        /** See {@link TextStyle.wordWrapWidth} */\n        wordWrapWidth: 100,\n    };\n\n    // colors!!\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillInput;\n\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: StrokeInput;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n\n    private _padding: number;\n\n    protected _styleKey: string;\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @member {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n    set align(value: TextStyleAlign) { this._align = value; this.update(); }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n    set breakWords(value: boolean) { this._breakWords = value; this.update(); }\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = this._createProxy({ ...TextStyle.defaultDropShadow, ...value });\n        }\n        else\n        {\n            this._dropShadow = value ? this._createProxy({ ...TextStyle.defaultDropShadow }) : null;\n        }\n\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n    set fontFamily(value: string | string[]) { this._fontFamily = value; this.update(); }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n    set fontSize(value: string | number)\n    {\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n    /**\n     * The font style.\n     * @member {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n    set fontStyle(value: TextStyleFontStyle)\n    {\n        this._fontStyle = value.toLowerCase() as TextStyleFontStyle;\n        this.update();\n    }\n    /**\n     * The font variant.\n     * @member {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n    set fontVariant(value: TextStyleFontVariant) { this._fontVariant = value; this.update(); }\n    /**\n     * The font weight.\n     * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n    set fontWeight(value: TextStyleFontWeight) { this._fontWeight = value; this.update(); }\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n    set leading(value: number) { this._leading = value; this.update(); }\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n    set letterSpacing(value: number) { this._letterSpacing = value; this.update(); }\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n    set lineHeight(value: number) { this._lineHeight = value; this.update(); }\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     */\n    get padding(): number { return this._padding; }\n    set padding(value: number) { this._padding = value; this.update(); }\n\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n    get trim(): boolean { return this._trim; }\n    set trim(value: boolean) { this._trim = value; this.update(); }\n    /**\n     * The baseline of the text that is rendered.\n     * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n    set textBaseline(value: TextStyleTextBaseline) { this._textBaseline = value; this.update(); }\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @member {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n    set whiteSpace(value: TextStyleWhiteSpace) { this._whiteSpace = value; this.update(); }\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n    set wordWrap(value: boolean) { this._wordWrap = value; this.update(); }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n    set wordWrapWidth(value: number) { this._wordWrapWidth = value; this.update(); }\n\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n    get fill(): FillInput\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillInput)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () =>\n            {\n                this._fill = toFillStyle(\n                    { ...this._originalFill as FillStyle },\n                    GraphicsContext.defaultFillStyle\n                );\n            });\n        }\n\n        this._fill = toFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): StrokeInput\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: StrokeInput)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () =>\n            {\n                this._stroke = toStrokeStyle(\n                    { ...this._originalStroke as StrokeStyle },\n                    GraphicsContext.defaultStrokeStyle\n                );\n            });\n        }\n\n        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    protected _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this);\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._styleKey = null;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    get styleKey()\n    {\n        return this._styleKey || this._generateKey();\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n        });\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n\n    private _createProxy<T extends object>(value: T, cb?: (property: string, newValue: any) => void): T\n    {\n        return new Proxy<T>(value, {\n            set: (target, property, newValue) =>\n            {\n                target[property as keyof T] = newValue;\n                cb?.(property as string, newValue);\n                this.update();\n\n                return true;\n            }\n        });\n    }\n\n    private _isFillStyle(value: FillInput): value is FillStyle\n    {\n        return ((value ?? null) !== null\n            && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern));\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as TextStyleOptions & {\n        dropShadowAlpha?: number;\n        dropShadowAngle?: number;\n        dropShadowBlur?: number;\n        dropShadowColor?: number;\n        dropShadowDistance?: number;\n        fillGradientStops?: number[];\n        strokeThickness?: number;\n    };\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance:   oldStyle.dropShadowDistance ?? defaults.distance,\n        };\n    }\n\n    if (oldStyle.strokeThickness !== undefined)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n        let obj: FillStyle = {};\n\n        // handles stroke: 0x0, stroke: { r: 0, g: 0, b: 0, a: 0 } stroke: new Color(0x0)\n        if (Color.isColorLike(color as ColorSource))\n        {\n            obj.color = color as ColorSource;\n        }\n        // handles stroke: new FillGradient()\n        else if (color instanceof FillGradient || color instanceof FillPattern)\n        {\n            obj.fill = color as FillGradient | FillPattern;\n        }\n        // handles stroke: { color: 0x0 } or stroke: { fill: new FillGradient() }\n        else if (Object.hasOwnProperty.call(color, 'color') || Object.hasOwnProperty.call(color, 'fill'))\n        {\n            obj = color as FillStyle;\n        }\n        else\n        {\n            throw new Error('Invalid stroke value.');\n        }\n\n        style.stroke = {\n            ...obj,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fillGradientStops))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        let fontSize: number;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style.fontSize == null)\n        {\n            style.fontSize = TextStyle.defaultTextStyle.fontSize;\n        }\n        else if (typeof style.fontSize === 'string')\n        {\n            // eg '34px' to number\n            fontSize = parseInt(style.fontSize as string, 10);\n        }\n        else\n        {\n            fontSize = style.fontSize as number;\n        }\n\n        const gradientFill = new FillGradient(0, 0, 0, fontSize * 1.7);\n\n        const fills: number[] = oldStyle.fillGradientStops\n            .map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fills.forEach((number, index) =>\n        {\n            const ratio = index / (fills.length - 1);\n\n            gradientFill.addColorStop(ratio, number);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @memberof text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { TextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = TextMetrics.measureText('Your text', style);\n * @memberof text\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|ÉqÅ';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) => [...segmenter.segment(s)].map((x) => x.segment);\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result !== undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@see TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    private static readonly _measurementCache: Record<string, CanvasTextMetrics> = {};\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}:${style.styleKey}`;\n\n        // TODO - if we find this starts to go nuts with memory, we can remove the cache\n        // or instead just stick a usage tick that we increment each time we return it.\n        // if some are not used, we can just tidy them up!\n        if (CanvasTextMetrics._measurementCache[textKey]) return CanvasTextMetrics._measurementCache[textKey];\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // CanvasTextMetrics._measurementCache[textKey] = measurements;\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        const metrics = context.measureText(text);\n        let metricWidth = metrics.width;\n        const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n        const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n\n        if (metricWidth > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                metricWidth -= letterSpacing;\n                boundsWidth -= letterSpacing;\n            }\n            else\n            {\n                const val = (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n\n                metricWidth += val;\n                boundsWidth += val;\n            }\n        }\n\n        // NOTE: this is a bit of a hack as metrics.width and the bounding box width do not measure the same thing\n        // We can't seem to exclusively use one or the other, so are taking the largest of the two\n        return Math.max(metricWidth, boundsWidth);\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convenience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                tokens.push(char);\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (ex)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n","import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/FillTypes';\n\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D): string | CanvasGradient | CanvasPattern\n{\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n    }\n    else if (!fillStyle.fill)\n    {\n        // fancy set up...\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n\n        // create an inverted scale matrix..\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill;\n\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill;\n\n        if (fillGradient.type === 'linear')\n        {\n            const gradient = context.createLinearGradient(\n                fillGradient.x0,\n                fillGradient.y0,\n                fillGradient.x1,\n                fillGradient.y1\n            );\n\n            fillGradient.gradientStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n\n            return gradient;\n        }\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../../container/Container';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.resolutionChange.add(this);\n        this._renderer.renderableGC.addManagedHash(this, '_gpuText');\n    }\n\n    public resolutionChange()\n    {\n        for (const i in this._gpuText)\n        {\n            const gpuText = this._gpuText[i];\n\n            if (!gpuText) continue;\n\n            const text = gpuText.batchableSprite.renderable as Text;\n\n            if (text._autoResolution)\n            {\n                text._resolution = this._renderer.resolution;\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite._batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        text.off('destroyed', this._destroyRenderableBound);\n\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        const padding = text._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.transform = text.groupTransform;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', this._destroyRenderableBound);\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n","import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n","import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { TextOptions } from '../AbstractText';\nimport type { Text } from '../Text';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    public getTexture(options: TextOptions): Texture;\n    public getTexture(options: TextOptions | string, resolution?: number, style?: TextStyle, _textKey?: string): Texture\n    {\n        if (typeof options === 'string')\n        {\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n\n            options = {\n                text: options,\n                style,\n                resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(\n            options as {text: string, style: TextStyle, resolution?: number}\n        );\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    public createTextureAndCanvas(options: {text: string, style: TextStyle, resolution?: number})\n    {\n        const { text, style } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        return { texture, canvasAndContext };\n    }\n\n    public getManagedTexture(text: Text)\n    {\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        const textKey = text._getKey();\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.textBaseline = style.textBaseline;\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { HTMLTextStyle } from '../../text-html/HtmlTextStyle';\nimport type { TextStyle } from '../TextStyle';\n\nconst valuesToIterateForKeys: Partial<keyof TextStyle | keyof HTMLTextStyle>[] = [\n    'align',\n    'breakWords',\n    'cssOverrides',\n    'fontVariant',\n    'fontWeight',\n    'leading',\n    'letterSpacing',\n    'lineHeight',\n    'padding',\n    'textBaseline',\n    'trim',\n    'whiteSpace',\n    'wordWrap',\n    'wordWrapWidth',\n    'fontFamily',\n    'fontStyle',\n    'fontSize',\n] as const;\n\n/**\n * Generates a unique key for the text style.\n * @param style - The style to generate a key for.\n * @returns the key for the style.\n */\nexport function generateTextStyleKey(style: TextStyle): string\n{\n    const key = [];\n\n    let index = 0;\n\n    for (let i = 0; i < valuesToIterateForKeys.length; i++)\n    {\n        const prop = `_${valuesToIterateForKeys[i]}`;\n\n        key[index++] = style[prop as keyof typeof style];\n    }\n\n    index = addFillStyleKey(style._fill, key as string[], index);\n    index = addStokeStyleKey(style._stroke, key as string[], index);\n    index = addDropShadowKey(style.dropShadow, key as string[], index);\n\n    return key.join('-');\n}\n\nfunction addFillStyleKey(fillStyle: ConvertedFillStyle, key: (number | string)[], index: number)\n{\n    if (!fillStyle) return index;\n\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = fillStyle.fill?.styleKey;\n\n    return index;\n}\n\nfunction addStokeStyleKey(strokeStyle: ConvertedStrokeStyle, key: (number | string)[], index: number)\n{\n    if (!strokeStyle) return index;\n\n    index = addFillStyleKey(strokeStyle, key, index);\n\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n\n    return index;\n}\n\nfunction addDropShadowKey(dropShadow: TextStyle['dropShadow'], key: (number | string)[], index: number)\n{\n    if (!dropShadow) return index;\n\n    key[index++] = dropShadow.alpha;\n    key[index++] = dropShadow.angle;\n    key[index++] = dropShadow.blur;\n    key[index++] = dropShadow.distance;\n    key[index++] = Color.shared.setValue(dropShadow.color).toNumber();\n\n    return index;\n}\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n","type TypedArray = Float32Array | Uint32Array | Int32Array | Uint8Array;\n\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @memberof utils\n */\nexport class ViewableBuffer\n{\n    /** The size of the buffer in bytes. */\n    public size: number;\n\n    /** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n    public rawBinaryData: ArrayBuffer;\n\n    /** View on the raw binary data as a `Uint32Array`. */\n    public uint32View: Uint32Array;\n\n    /** View on the raw binary data as a `Float32Array`. */\n    public float32View: Float32Array;\n    public uint16View: Uint16Array;\n\n    private _int8View: Int8Array;\n    private _uint8View: Uint8Array;\n    private _int16View: Int16Array;\n    private _int32View: Int32Array;\n    private _float64Array: Float64Array;\n    private _bigUint64Array: BigUint64Array;\n\n    /**\n     * @param length - The size of the buffer in bytes.\n     */\n    constructor(length: number);\n\n    /**\n     * @param arrayBuffer - The source array buffer.\n     */\n    constructor(arrayBuffer: ArrayBuffer);\n\n    constructor(sizeOrBuffer: number | ArrayBuffer | Uint8Array)\n    {\n        if (typeof sizeOrBuffer === 'number')\n        {\n            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        }\n        else if (sizeOrBuffer instanceof Uint8Array)\n        {\n            this.rawBinaryData = sizeOrBuffer.buffer;\n        }\n        else\n        {\n            this.rawBinaryData = sizeOrBuffer;\n        }\n\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n\n        this.size = this.rawBinaryData.byteLength;\n    }\n\n    /** View on the raw binary data as a `Int8Array`. */\n    get int8View(): Int8Array\n    {\n        if (!this._int8View)\n        {\n            this._int8View = new Int8Array(this.rawBinaryData);\n        }\n\n        return this._int8View;\n    }\n\n    /** View on the raw binary data as a `Uint8Array`. */\n    get uint8View(): Uint8Array\n    {\n        if (!this._uint8View)\n        {\n            this._uint8View = new Uint8Array(this.rawBinaryData);\n        }\n\n        return this._uint8View;\n    }\n\n    /**  View on the raw binary data as a `Int16Array`. */\n    get int16View(): Int16Array\n    {\n        if (!this._int16View)\n        {\n            this._int16View = new Int16Array(this.rawBinaryData);\n        }\n\n        return this._int16View;\n    }\n\n    /** View on the raw binary data as a `Int32Array`. */\n    get int32View(): Int32Array\n    {\n        if (!this._int32View)\n        {\n            this._int32View = new Int32Array(this.rawBinaryData);\n        }\n\n        return this._int32View;\n    }\n\n    /** View on the raw binary data as a `Float64Array`. */\n    get float64View(): Float64Array\n    {\n        if (!this._float64Array)\n        {\n            this._float64Array = new Float64Array(this.rawBinaryData);\n        }\n\n        return this._float64Array;\n    }\n\n    /** View on the raw binary data as a `BigUint64Array`. */\n    get bigUint64View(): BigUint64Array\n    {\n        if (!this._bigUint64Array)\n        {\n            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        }\n\n        return this._bigUint64Array;\n    }\n\n    /**\n     * Returns the view of the given type.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *    `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - typed array of given type\n     */\n    public view(type: string): TypedArray\n    {\n        return (this as any)[`${type}View`];\n    }\n\n    /** Destroys all buffer references. Do not use after calling this. */\n    public destroy(): void\n    {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n\n    /**\n     * Returns the size of the given type in bytes.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *   `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - size of the type in bytes\n     */\n    public static sizeOf(type: string): number\n    {\n        switch (type)\n        {\n            case 'int8':\n            case 'uint8':\n                return 1;\n            case 'int16':\n            case 'uint16':\n                return 2;\n            case 'int32':\n            case 'uint32':\n            case 'float32':\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n"],"names":["module","exports","path","data","replace","segment","_","command","args","type","toLowerCase","numbers","match","number","map","Number","parseValues","length","push","concat","splice","unshift","Error","a","c","h","l","m","q","s","t","v","z","ResizePlugin","init","options","Object","defineProperty","this","set","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","get","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","width","height","window","innerWidth","innerHeight","clientWidth","clientHeight","renderer","render","resizeTo","destroy","extension","ExtensionType","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","remove","add","UPDATE_PRIORITY","LOW","stop","start","Ticker","shared","oldTicker","extensions","FilterPipe","constructor","_renderer","filterEffect","container","instructionSet","renderPipes","batch","break","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","filter","WebGLPipes","WebGPUPipes","CanvasPipes","name","tempMatrix","Matrix","getFastGlobalBounds","target","bounds","clear","_getGlobalBoundsRecursive","isValid","renderGroup","applyMatrix","localTransform","parentRenderGroup","worldTransform","localDisplayStatus","measurable","manageEffects","effects","localBounds","boundsPool","boundsArea","addRect","viewBounds","addFrame","minX","minY","maxX","maxY","groupTransform","children","i","advanced","addBounds","copyTo","invert","relativeGroupTransform","return","quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","format","stride","offset","indexBuffer","Uint32Array","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_activeFilterData","backTexture","filters","_getFilterData","filterData","skip","renderables","matrix","renderable","globalDisplayStatus","getGlobalRenderableBounds","filterArea","colorTextureSource","renderTarget","colorTexture","source","resolution","Infinity","padding","antialias","blendRequired","enabled","clipToViewport","Math","min","_resolution","compatibleRenderers","backBuffer","useBackBuffer","warn","scale","viewPort","rootViewPort","fitBounds","ceil","pad","isPositive","previousRenderSurface","renderSurface","inputTexture","TexturePool","getOptimalTexture","bind","globalUniforms","Texture","EMPTY","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","style","apply","returnTexture","flip","flop","lastRenderSurface","backgroundResolution","x","y","floor","copyToTexture","applyFilter","input","output","Point","isFinalTarget","rootRenderTarget","currentIndex","filterUniforms","uniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","frame","pixelWidth","pixelHeight","rootTexture","isRoot","update","uniformBatch","batchUniforms","getUboResource","groups","encoder","draw","geometry","shader","state","_state","topology","RendererType","WEBGL","Bounds","calculateSpriteMatrix","outputMatrix","sprite","mappedMatrix","_source","prepend","texture","translate","anchor","WebGLSystem","WebGPUSystem","fragTemplate","join","generateIfTestSrc","maxIfs","src","maxTexturesPerBatchCache","getMaxTexturesPerBatch","gl","getTestContext","getParameter","MAX_TEXTURE_IMAGE_UNITS","createShader","FRAGMENT_SHADER","fragmentSrc","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","checkMaxIfStatementsInShader","getExtension","loseContext","addBits","srcParts","parts","part","toLocaleLowerCase","sanitisedPart","findHooksRx","compileHooks","programSrc","hook","forEach","extractInputs","fragmentSource","out","regex","exec","compileInputs","fragments","template","sort","arguments","undefined","results","fragment","header","mainInput","finalString","inValue","cleanedString","extractOutputs","injectBits","templateSrc","fragmentParts","cacheMap","create","bitCacheMap","Map","CACHE_UID","compileHighShader","_ref","bits","cacheId","generateCacheId","vertex","vertexFragments","shaderBit","fragmentFragments","compiledVertex","index","mainStruct","indexOf","mainStart","mainEnd","extractVariableName","compiledCode","compileOutputs","compiledFragment","compileInputsAndOutputs","compileBits","compileHighShaderGl","_ref2","highFragment","has","b","vertexParts","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","GpuProgram","from","entryPoint","compileHighShaderGlProgram","GlProgram","colorBit","main","colorBitGl","textureBatchBitGpuCache","generateBindingSrc","maxTextures","bindingIndex","generateSampleSrc","generateTextureBatchBit","end","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","roundPixelsBit","roundPixelsBitGl","maxFragmentPrecision","getMaxFragmentPrecision","getShaderPrecisionFormat","shaderFragment","HIGH_FLOAT","precision","fragmentNameCache","VertexNameCache","processes","stripVersion","isES300","ensurePrecision","isFragment","maxSupportedPrecision","maxSupportedFragmentPrecision","maxSupportedVertexPrecision","substring","requestedFragmentPrecision","requestedVertexPrecision","addProgramDefines","setProgramName","nameCache","insertVersion","programCache","_GlProgram","defaultOptions","preprocessorOptions","preferredFragmentPrecision","preferredVertexPrecision","keys","processKey","processOptions","_key","createIdFromString","_attributeData","_uniformData","_uniformBlockData","transformFeedbackVaryings","key","batchSamplersUniformGroupHash","getBatchSamplersUniformGroup","batchSamplersUniformGroup","sampleValues","Int32Array","uTextures","size","isStatic","context","isContextLost","canvas","DOMAdapter","createCanvas","getContext","resources","_dirty","resource","_updateKey","keyParts","_resourceId","currentResource","off","onResourceChange","on","getResource","_touch","tick","_touched","destroyed","WGSL_TO_VERTEX_TYPES","f32","vec2f","vec3f","vec4f","i32","u32","bool","extractStructAndGroups","wgsl","groupPattern","bindingPattern","namePattern","typePattern","structMemberPattern","structName","item","group","parseInt","binding","isUniform","structs","struct","members","reduce","acc","member","name2","split","trim","some","ShaderStage","ShaderStage2","_layoutKey","_attributeLocationsKey","layout","gpuLayout","structsAndGroups","vertexStructsAndGroups","fragmentStructsAndGroups","structNameSet","Set","dupeGroupKeySet","removeStructAndGroupDuplicates","generateLayoutHash","visibility","VERTEX","FRAGMENT","sampler","sampleType","viewDimension","multisampled","generateGpuLayoutGroups","autoAssignGlobalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","bigKey","attributeData","mainVertStart","arrowFunctionStart","functionArgsSubstring","inputsRegex","location","getAttributeInfoFromFormat","instance","extractAttributesFromGpuProgram","Buffer","EventEmitter","usage","label","shrinkToFit","uid","_resourceType","_updateID","Array","_data","byteLength","mappedAtCreation","descriptor","setDataWithSize","static","BufferUsage","STATIC","syncGPU","_updateSize","BYTES_PER_ELEMENT","emit","oldData","sizeInBytes","removeAllListeners","BufferUsage2","ensureIsBuffer","INDEX","COPY_DST","instanceCount","_bounds","_boundsDirty","buffers","addAttribute","addIndex","onBufferUpdate","getAttribute","id","getIndex","getBuffer","getSize","attribute","attributeOption","isArray","ensureIsAttribute","attributeId","byteSize","getGeometryBounds","destroyBuffers","attributeFormatData","uint8x2","normalised","uint8x4","sint8x2","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","Shader","_uniformBindMap","_ownedBindGroups","gpuProgram","glProgram","groupMap","WEBGPU","nameHash","j","uniformName","groupData","bindTick","_buildResourceAccessor","addResource","groupIndex","bindIndex","_a","_b","uniformsOut","destroyPrograms","bindGroup","gpu","rest","UNIFORM_TYPES_VALUES","UNIFORM_TYPES_MAP","getDefaultUniformValue","_UniformGroup","uniformStructures","isUniformGroup","_dirtyId","uniformData","ubo","_signature","blendModeIds","normal","multiply","screen","overlay","erase","max","_State","blendMode","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","default2d","State","BLEND_TO_NPM","getAdjustedBlendModeBlend","textureSource","alphaMode","CanvasPool","canvasOptions","_canvasPool","enableFullScreen","_createCanvasAndContext","getOptimalCanvasAndContext","minWidth","minHeight","nextPow2","canvasAndContext","returnCanvasAndContext","clearRect","count","textureOptions","_poolKeyHash","_texturePool","createTexture","TextureSource","autoGarbageCollect","frameWidth","frameHeight","po2Width","po2Height","updateUvs","getSameSizeTexture","renderTexture","destroyTextures","textures","idCounts","idHash","groupId","RendererType2","color32BitToUniform","abgr","alpha","GraphicsPipe","adaptor","_graphicsBatchesHash","_destroyRenderableBound","destroyRenderable","_adaptor","renderableGC","addManagedHash","validateRenderable","graphics","wasBatched","gpuContext","graphicsContext","updateGpuContext","isBatchable","addRenderable","didViewUpdate","_rebuild","_addToBatcher","updateRenderable","batches","_batcher","updateElement","_removeBatchForRenderable","isRenderable","getGpuContext","customShader","groupBlendMode","uTransformMatrix","uRound","_roundPixels","groupColorAlpha","uColor","_initBatchesForRenderable","batched","batchPipe","_getBatchesForRenderable","addToBatch","roundPixels","batchClone","BigPool","BatchableGraphics","graphicsUid","GraphicsContextSystem","identityMatrix","packAsQuad","batcherName","applyTransform","_batch","uvs","geometryData","positions","vertices","indices","color","rgb","baseColor","bgr","color1","color2","groupColor","groupAlpha","transform","gpuBuffer","indexOffset","indexSize","attributeOffset","attributeSize","reset","Circle","radius","clone","contains","r2","dx","dy","strokeContains","r","w2","distance","sqrt","getBounds","Rectangle","copyFrom","circle","Ellipse","halfWidth","halfHeight","normx","normy","halfStrokeWidth","innerA","innerB","outerA","outerB","normalizedX","normalizedY","ellipse","squaredDistanceToLineSegment","x1","y1","x2","y2","d","lenSq","xx","yy","param","Polygon","_len","points","flat","p","il","closePath","slice","polygon","inside","xi","yi","xj","yj","strokeWidth","halfStrokeWidthSqrd","iterationLength","n","pointsDesc","currentPoint","lastX","lastY","isCornerWithinStroke","pX","pY","cornerX","cornerY","RoundedRectangle","rectangle","radius2","innerX","innerY","rightBound","bottomBound","FLT_EPSILON","buildAdaptiveBezier","sX","sY","cp1x","cp1y","cp2x","cp2y","eX","eY","smoothness","distanceTolerance","bezierSmoothness","recursive","begin","x3","y3","x4","y4","level","PI","x12","y12","x23","y23","x34","y34","x123","y123","x234","y234","x1234","y1234","d2","abs","d3","buildAdaptiveQuadratic","buildArc","clockwise","steps","dist","pow","f","nx","cos","ny","sin","TAU","centerX","centerY","ang1","ang2","mapToEllipse","rx","ry","cosPhi","sinPhi","out2","xp","yp","approxUnitArc","a1","tan","vectorAngle","ux","uy","vx","vy","dot","acos","buildArcToSvg","px","py","cx","cy","xAxisRotation","largeArcFlag","sweepFlag","pxp","pyp","lambda","getArcCenter","rxSq","rySq","pxpSq","pypSq","radicant","centerXp","centerYp","vx1","vy1","vx2","vy2","ratio","segments","outCurvePoint","curve","tempRectangle","ShapePath","graphicsPath2D","shapePrimitives","_currentPoly","_graphicsPath2D","moveTo","startPoly","lineTo","_ensurePoly","fromX","fromY","arc","startAngle","endAngle","counterclockwise","arcTo","b1","a2","b2","mm","dd","cc","tt","k1","k2","j1","j2","qx","qy","atan2","buildArcTo","arcToSvg","bezierCurveTo","currentPoly","quadraticCurveTo","smoothing","endPoly","addPath","isIdentity","instructions","finish","rect","w","drawShape","poly","close","regularPoly","sides","rotation","delta","angle","roundPoly","corner","sideLength","internalAngle","x0","y0","roundShape","useQuadratic","g","p1","p2","pointLerp","numPoints","thisPoint","pRadius","lastPoint","nextPoint","lastEdgeLength","nextEdgeLength","roundedShapeQuadraticCurve","vecFrom","pp","len","sharpCorner","p3","v1","v2","asin","radDirection","drawDirection","halfAngle","cRadius","lenOut","cX","cY","roundedShapeArc","filletRect","fillet","maxFillet","inset","right","bottom","dir","chamferRect","chamfer","radiusX","radiusY","roundRect","shape","lastShape","lx","ly","tempX","tx","ty","buildPath","shapePrimitive","boundsRect","GraphicsPath","svgPath","commands","parse","subpaths","currentSubPath","bezierCurveToShort","quadraticCurveToShort","startX","startY","SVGToGraphicsPath","shapePath","_shapePath","_len2","_key2","_len3","_key3","_len4","_key4","last","getLastPoint","currentX","currentY","_len5","_key5","_len6","_key6","_len7","_key7","_len8","_key8","cpx1","cpy1","_len9","_key9","_len10","_key10","_len11","_key11","_len12","_key12","_len13","_key13","_len14","_key14","_len15","_key15","star","innerRadius","deep","newGraphicsPath2D","cpx2","cpy2","adjustTransform","lastInstruction","currentMatrix","SVGParser","svg","div","document","createElement","innerHTML","querySelector","renderChildren","session","fillStyle","strokeStyle","f1","s1","useFill","useStroke","styleParts","stylePart","Color","setValue","toNumber","stroke","parseFloatAttribute","fill","parseStyle","pointsString","graphicsPath","nodeName","beginPath","console","info","defaultValue","tmpPoint","_GraphicsContext","dirty","batchMode","_activePath","_transform","_fillStyle","defaultFillStyle","_strokeStyle","defaultStrokeStyle","_stateStack","_tick","toFillStyle","toStrokeStyle","setFillStyle","setStrokeStyle","tint","dw","dh","image","onUpdate","deprecation","v8_0_0","_initNextPathLocation","cut","holePath","hole","transformedX","transformedY","cpx","cpy","restore","save","getTransform","resetTransform","identity","rotate","setTransform","append","containsPoint","point","hasHit","k","shapes","transformedPoint","applyInverse","holes","holeShapes","destroyTextureSource","WHITE","alignment","miterLimit","cap","GraphicsContext","cachedGroups","getTextureBatchBindGroup","imul","bindGroupResources","generateTextureBatchBindGroup","fastCopy","sourceBuffer","destinationBuffer","lengthDouble","sourceFloat64View","Float64Array","remainingBytes","sourceUint8View","Uint8Array","BatchTextureArray","ids","Batch","gpuBindGroup","batcher","batchPool","batchPoolIndex","getBatchFromPool","returnBatchToPool","BATCH_TICK","_Batcher","batchIndex","_elements","attributesInitialSize","indicesInitialSize","attributeBuffer","ViewableBuffer","Uint16Array","elementSize","elementStart","_batchIndexStart","_batchIndexSize","batchableObject","_indexStart","_attributeStart","vertexSize","checkAndUpdateTexture","textureId","_textureId","packQuadAttributes","float32View","uint32View","packAttributes","elements","textureBatch","firstElement","_resizeAttributeBuffer","_resizeIndexBuffer","element","adjustedBlendMode","breakRequired","_batchTick","_finishBatch","_textureBindLocation","packQuadIndex","packIndex","indexStart","ensureAttributeBuffer","ensureIndexBuffer","newSize","newArrayBuffer","rawBinaryData","newIndexBuffer","indicesOffset","Batcher","placeHolderBufferData","placeHolderIndexData","BatchGeometry","aUV","aColor","aTextureIdAndRound","DefaultShader","batchSamplers","defaultShader","_DefaultBatcher","textureIdAndRound","wt","argb","i2","w0","w1","h0","h1","DefaultBatcher","transformVertices","buildCircle","ShapeBuilder","build","roundedRect","j3","j4","y22","x02","y02","x22","triangulate","verticesStride","verticesOffset","centerIndex","buildEllipse","buildRoundedRectangle","square","innerWeight","outerWeight","verts","exx","eyy","eix","eiy","eox","eoy","round","sx","sy","ex","ey","cx2p0x","cy2p0y","angle0","angle1","angleDiff","absAngleDiff","segCount","angleInc","triangulateWithHoles","triangles","earcut","emptyArray","buildPolygon","buildRectangle","rectData","verticesIndex","buildTriangle","shapeBuilders","handleByMap","tempRect","addTextureToGeometryData","vertOffset","textureUvs","graphicsBatch","addShapePathToGeometryData","isStroke","lineStyle","flipAlignment","closed","_verticesStride","_verticesOffset","eps","orientation","area","getOrientationOfPoints","firstPoint","closedShape","closedPath","midPointX","midPointY","indexCount","widthSquared","miterLimitSquared","perpX","perpY","perp1x","perp1y","dx0","dy0","dx1","dy1","cross","c1","c2","pDist","imx","imy","omx","omy","insideWeight","curveEps","buildLine","holeIndices","otherPoints","holeArrays","holePrimitives","holePrimitive","holePoints","getHoleArrays","uvsOffset","textureMatrix","uvsStride","buildUvs","buildSimpleUvs","GpuGraphicsContext","GraphicsContextRenderData","InstructionSet","v8_3_4","_GraphicsContextSystem","_gpuContextHash","_graphicsDataContextHash","getContextRenderData","_initContextRenderData","_initContext","_cleanGraphicsContextData","buildContextBatches","graphicsData","drawBatches","onGraphicsContextDestroy","CanvasSystem","_FillGradient","gradientStops","_styleKey","addColorStop","toHexa","buildLinearGradient","defaultSize","defaultTextureSize","ctx","gradient","createLinearGradient","fillRect","ImageSource","addressModeU","addressModeV","styleKey","stops","toArray","FillGradient","repetitionMap","repeat","FillPattern","repetition","isFillPattern","isFillGradient","handleFillPattern","defaultStyle","handleFillGradient","objectStyle","isColorLike","temp","handleColorLike","sourceStyle","addressMode","handleFillObject","MeshPipe","localUniformsBindGroup","_meshDataHash","_gpuBatchableMeshHash","mesh","meshData","_getMeshData","isBatched","_geometry","batchableMesh","_getBatchableMesh","gpuBatchableMesh","_texture","gpuMesh","_initMeshData","_initBatchableMesh","BatchableMesh","_uvUpdateId","_textureMatrixUpdateId","uvBuffer","transformedUvs","isSimple","_transformedUvs","multiplyUvs","_MeshGeometry","shrinkBuffersToFit","MeshGeometry","GlParticleContainerAdaptor","particleContainerPop","uTexture","getBuffers","glType","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","createIndicesForQuads","outBuffer","totalIndices","generateUpdateFunction","properties","dynamic","funcFragments","property","code","functionSource","Function","ParticleBuffer","_size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","attributeInfo","_dynamicStride","_staticStride","staticAttributeBuffer","dynamicAttributeBuffer","dynamicOffset","staticOffset","_staticBuffer","_dynamicBuffer","attributeName","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","keyGen","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","ParticleShader","uSampler","TextureStyle","uTranslationMatrix","uResolution","ParticleContainerPipe","_gpuBufferHash","_renderable","_initBuffer","_properties","_childrenDirty","transformationMatrix","globalUniformData","projectionMatrix","GlParticleContainerPipe","GpuParticleContainerAdaptor","getUniformBindGroup","getTextureBindGroup","GpuParticleContainerPipe","_PlaneGeometry","super","verticesX","verticesY","total","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","PlaneGeometry","_NineSliceGeometry","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","updatePositions","scaleW","scaleH","_uvw","_uvh","NineSliceGeometry","NineSliceSpritePipe","_gpuSpriteHash","gpuSprite","_getGpuSprite","_updateBatchableSprite","batchableSprite","_initGPUSprite","localUniformBit","localUniformBitGl","tilingBit","tilingBitGl","TilingSpriteShader","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","updateUniforms","anchorX","anchorY","textureWidth","textureHeight","mapCoord","QuadGeometry","sharedQuad","TilingSpritePipe","_tilingSpriteDataHash","tilingSpriteData","_getTilingSpriteData","couldBatch","canBatch","_updateCanBatch","tilingSprite","_updateBatchableMesh","_tileTransform","_initTilingSpriteData","renderableData","_applyAnchorToTexture","array","setUvs","setPositions","_nonPowOf2wrapping","supports","nonPowOf2wrapping","isPowerOfTwo","BatchableSprite","Graphics","ViewContainer","_context","_ownedContext","onViewUpdate","allowChildren","_callContextMethod","method","_len16","_key16","_len17","_key17","_len18","_key18","_len19","_key19","_len20","_key20","_len21","_key21","_len22","_key22","_len23","_key23","_len24","_key24","_len25","_key25","_len26","_key26","rotateTransform","_len27","_key27","scaleTransform","_len28","_key28","_len29","_key29","_len30","_key30","translateTransform","_len31","_key31","beginFill","endFill","drawCircle","_len32","_key32","drawEllipse","_len33","_key33","drawPolygon","_len34","_key34","drawRect","_len35","_key35","drawRoundedRect","_len36","_key36","drawStar","_len37","_key37","localUniformMSDFBit","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","uDistance","AbstractBitmapFont","chars","lineHeight","fontFamily","fontMetrics","fontSize","ascent","descent","baseLineOffset","distanceField","range","pages","applyFillAsTint","baseMeasurementFontSize","baseRenderedFontSize","font","pageTextures","distanceFieldRange","distanceFieldType","page","resolveCharacters","result","startCode","charCodeAt","endCode","String","fromCharCode","_DynamicBitmapFont","_padding","_measureCache","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","_textureSize","textureSize","_mipmap","mipmap","overrideFill","_fill","requestedFontSize","fontStringFromTextStyle","overrideSize","_stroke","_style","skipKerning","CanvasTextMetrics","measureFont","ensureCharacters","charList","char","includes","self","pageData","_nextPage","fontScale","maxCharHeight","skipTexture","metrics","measureText","textureGlyphWidth","fontStyle","paddedWidth","paddedHeight","pageData2","xAdvance","dropShadow","codePointAt","xOffset","yOffset","kerning","_drawGlyph","_applyKerning","newChars","measureCache","first","second","amount","textureResolution","_setupContext","autoGenerateMipmaps","textBaseline","strokeThickness","lineWidth","lineJoin","getCanvasFillStyle","shadowOptions","dropShadowBlur","blur","dropShadowDistance","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","text","fontProperties","strokeText","fillText","TextStyle","DynamicBitmapFont","getBitmapTextLayout","trimEnd","layoutData","offsetY","lines","charPositions","spaceWidth","spacesIndex","currentLine","previousChar","firstWord","currentWord","spaceWord","nextWord","word","position","nextLine","lastChar","adjustedLetterSpacing","letterSpacing","adjustedWordWrapWidth","wordWrapWidth","isEnd","charData","test","wordWrap","nextCharWidth","align","measurementData","line","alignCenter","alignRight","indy","spaceIndex","totalSpaces","alignJustify","fontCount","BitmapFontManager","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","getFont","fontFamilyKey","lastIndexOf","Cache","fnt","once","dynamicFont","getLayout","bitmapFont","install","textStyle","flatChars","uninstall","cacheKey","BitmapTextPipe","_gpuBitmapText","bitmapText","graphicsRenderable","_getGpuBitmapText","_didTextUpdate","_updateContext","syncWithProxy","_updateDistanceField","_destroyRenderableByUid","renderableUid","proxyGraphics","bitmapTextLayout","_anchor","_x","_y","initGpuText","proxyRenderable","worldScale","proxy","HTMLTextPipe","_gpuText","runners","resolutionChange","gpuText","_autoResolution","htmlText","_getGpuText","newKey","_getKey","textureNeedsUploading","currentKey","_updateText","_destroyRenderableById","htmlTextUid","decreaseReferenceCount","_updateGpuText","catch","e","error","updateQuadBounds","generatingTexture","getManagedTexture","gpuTextData","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","createElementNS","foreignObject","domElement","styleElement","Image","setAttribute","overflow","appendChild","textStyleToCSS","cssStyles","toHex","fontWeight","fontVariant","whiteSpace","breakWords","strokeToCSS","dropShadowToCSS","cssOverrides","tagStyles","tagStyle","cssTagStyle","templates","tagStyleToCSS","dropShadowStyle","setAlpha","HTMLTextStyle","_cssOverrides","_generateKey","generateTextStyleKey","_cssStyle","cssStyle","addOverride","toAdd","removeOverride","toRemove","loadFontCSS","url","dataSrc","response","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","onerror","readAsDataURL","loadFontAsBase64","FontStylePromiseCache","tempHTMLTextRenderData","HTMLTextSystem","_activeTextures","_createCanvas","getTexture","_buildTexturePromise","textKey","_increaseReferenceCount","promise","then","usageCount","htmlTextData","fontFamilies","dedupe","matches","addFontFamily","fontFamily2","extractFontFamilies","fontCSS","fontPromises","all","getFontCss","defaultTextStyle","measured","fontStyleCSS","htmlTextRenderData","textContent","body","contentBounds","getBoundingClientRect","doublePadding","measureHtmlText","svgURL","XMLSerializer","serializeToString","getSVGUrl","delay","async","resolve2","setTimeout","onload","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","isSafari","drawImage","getTemporaryCanvasFromImage","getPo2TextureFromSource","initSource","activeTexture","_cleanUp","uploadMethodId","getReferenceCount","defaultFontOptions","_TextStyle","oldStyle","defaults","defaultDropShadow","dropShadowAlpha","dropShadowAngle","dropShadowColor","obj","hasOwnProperty","call","fillGradientStops","gradientFill","fills","convertV7Tov8Style","fullStyle","_align","_breakWords","_dropShadow","_createProxy","_fontFamily","_fontSize","_fontStyle","_fontVariant","_fontWeight","leading","_leading","_letterSpacing","_lineHeight","_trim","_textBaseline","_whiteSpace","_wordWrap","_wordWrapWidth","_originalFill","_isFillStyle","_originalStroke","cb","Proxy","newValue","contextSettings","willReadFrequently","_CanvasTextMetrics","experimentalLetterSpacingSupported","_experimentalLetterSpacingSupported","proto","getCanvasRenderingContext2D","prototype","lineWidths","maxLineWidth","_canvas","_measurementCache","__context","_measureText","useExperimentalLetterSpacing","experimentalLetterSpacing","textLetterSpacing","metricWidth","actualBoundingBoxLeft","boundsWidth","actualBoundingBoxRight","val","graphemeSegmenter","cache","collapseSpaces","_collapseSpaces","collapseNewlines","_collapseNewlines","canPrependSpaces","tokens","_tokenize","token","_isNewline","_addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","_getFromCache","canBreakWords","characters","wordWrapSplit","nextChar","canBreakChars","characterWidth","isLastToken","newLine","_trimRight","_newlines","_nextChar","_breakingSpaces","_token","_char","_index","_fonts","METRICS_STRING","BASELINE_SYMBOL","actualBoundingBoxAscent","actualBoundingBoxDescent","clearMetrics","__canvas","OffscreenCanvas","BASELINE_MULTIPLIER","HEIGHT_MULTIPLIER","Intl","Segmenter","segmenter","genericFontFamilies","fontSizeString","pattern","createPattern","fillPattern","fillGradient","CanvasTextPipe","textUid","canvasText","checkRow","checkColumn","top","CanvasTextSystem","getTextureSize","_textKey","createTextureAndCanvas","renderTextToCanvas","trimmed","TypeError","getImageData","left","getCanvasBoundingBox","lineCap","linePositionX","linePositionY","passesCount","isShadowPass","dsOffsetText","dsOffsetShadow","toRgbaString","linePositionYShift","_drawLetterSpacing","currentPosition","stringArray","previousWidth","currentWidth","currentChar","textStr","valuesToIterateForKeys","prop","addFillStyleKey","addStokeStyleKey","addDropShadowKey","tempBounds","sizeOrBuffer","ArrayBuffer","int8View","_int8View","Int8Array","uint8View","_uint8View","int16View","_int16View","Int16Array","int32View","_int32View","float64View","_float64Array","bigUint64View","_bigUint64Array","BigUint64Array","view","uint16View","sizeOf"],"sourceRoot":""}